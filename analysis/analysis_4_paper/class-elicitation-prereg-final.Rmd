---
title: "Comparison Class Elicitation Experiment "
author: "MH Tessler"
date: "October 29, 2019"
---

The comparison class elicitation experiment is a free prduction experiment where participants read a context sentence about a target object (NP) and paraphrase an utterance involving a gradable adjective by providing an explicit comparison class for the gradable adjective; we analyse the produced comparison classes and categorize them into "subordinate" and "superordinate" comparison classes.

# Analysis Outline

First, the raw responses are processed automatically by matching responses to keywords providing the essence of the respective comparison class: mostly, we match against the NPs of the sentence (referent NPs) and the anticipated superordinate of the item. In order to improve the automatic classification we lemmatize and correct for misspellings of the raw responses. 

Second, the responses which were not processed automatically are processed manually. From these responses, we looked for responses thatwere produced by at least three participants and noted these as consistent comparison classes that were different from the referent NP and the anticiapted superordinate. 

The analysis proceedes from simplest processing steps to more sophisticated processing steps, leading to the output of dataframes containing data passing these different processing steps. 

At the end, data visualisations and regression models can be found.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Load libraries.
library(knitr)
library(tidyverse)
library(tidyboot)
library(tidytext)
library(lme4)
library(ggthemes)
library(brms)
library(stringr)
theme_set(theme_few())

# check matching between strings
containsString_responses <- function(strng, substrng, clean_str, us_substr) {
  return(ifelse(length(strsplit(strng, substrng)[[1]]) > 1, 1,
    ifelse(length(strsplit(us_substr, clean_str)[[1]]) > 1, 1, 0)
  ))
}

containsString <- function(strng, substrng) {
  return(ifelse(length(strsplit(strng, substrng)[[1]]) > 1, 1,
    ifelse(length(strsplit(substrng, strng)[[1]]) > 1, 1, 0)
  ))
}
```

## Load data

```{r load data from csv, warnings=F}
df.trials <- read_csv("../../data/class-elicitation-prereg-final/class-elicitation-prereg-final-trials.csv")
df.subject <- read_csv("../../data/class-elicitation-prereg-final/class-elicitation-prereg-final-subject_information.csv")
df.attention <- read_csv("../../data/class-elicitation-prereg-final/class-elicitation-prereg-final-catch_trials.csv")
```

## Participant Exclusion 

Before the main trials, participants completed warm-up trials testing task comprehension (an easy paraphrase task of the kind appearing in the main trials). 

```{r comprehension check}
df.botcaptcha <- df.attention %>%
  filter(condition == "botcaptcha")

df.comprehension <- df.attention %>%
  filter(condition == "warm_up") %>%
  rowwise() %>%
  mutate(pass_comp = (
    containsString(tolower(response), "build") |
      containsString(tolower(response), "bulid") |
      containsString(tolower(response), "buid") |
      containsString(tolower(response), "skyscraper") |
      containsString(tolower(response), "skyscaper") |
      containsString(tolower(response), "structure") |
      containsString(tolower(response), "bulding") |
      containsString(tolower(response), "builing") |
      containsString(tolower(response), "bildin") |
      containsString(tolower(response), "towe")
  ))

df.comprehension %>% 
  group_by(pass_comp) %>%
  count() %>%
  kable()

# What did people write-in that was incorrect?
df.comprehension %>% 
  filter(!pass_comp) %>%
  View()
```

After the main trials, they completed a memory check trial asking which adjective-NP combinations appeared on the main trials. Participants are excluded if they answer less than 7 out of 10 memory check questions correctly or if they respond incorrectly on the warm-up trials.

```{r memory check}
df.memory <- df.attention %>%
  filter(condition == "memory_check") %>%
  group_by(workerid) %>%
  summarize(
    n_correct = sum(correct),
    pass_memory = n_correct >= 7
  )

df.memory %>%
  group_by(n_correct) %>%
  count() %>%
  kable()
```



```{r summarize catch trials}
df.attention.summary <- left_join(
  df.comprehension %>% select(workerid, pass_comp),
  df.memory %>% select(workerid, pass_memory)
) %>%
  mutate(pass_both = pass_comp & pass_memory)


df.attention.summary %>%
  group_by(pass_comp, pass_memory, pass_both) %>%
  count()
```

```{r apply exclusion critera}
df.trials.filtered <- df.trials %>%
  left_join(., df.attention.summary) %>%
  filter(pass_both)

n.total.responses <- df.trials.filtered %>%
  ungroup() %>%
  count() %>%
  pull(n)

paste("total number of responses =", n.total.responses)
```

```{r item counts}
d.item.count <- df.trials.filtered %>%
  group_by(stim_id, np_expectations, adj_polarity) %>%
  count()

d.item.count %>%
  ungroup() %>%
  group_by(n) %>%
  count() %>%
  ggplot(., aes(x = n, y = nn)) +
  geom_col() +
  xlab("n responses per item") +
  ylab("n items")
```

# Text preprocessing

## Invalid Responses: Nonsense + "similar"

### Nonsense

We exclude nonsense responses: These are the responses the are just the name of the speaker, just the adjective, an adjectival sentence without a comparison class or non-sense words. These invalid responses were extracted manually.

```{r list of invalid responses}
invalid.responses <- c(
  "unsure",
  # all the adjectives
  "long", "short", "tall", "dark", "light", "fast", "quick", "slow",
  "hard", "soft", "loud", "noisy", "quiet", "bright", "bruises",
  "expensive", "cheap", "big", "small", "strong", "weak", "warm", "hot", "cold",
  "heavy", "wide", "narrow",
  # all the actor names
  "alexander", "alicia", "cheep", "daniel", "darker",
  "david",
  "eric", "gabriel", "anthony", "william", "john", "tom", "lucas",
  "michael", "cameron", "stephen",
  "lee", "greg", "robert", "chrales", "gary", "josh", "simon",
  # female names
  "angela", "jennifer", "monica", "melinda", "veronica", "alicia",
  "maya", "sophie", "kim", "laura", "julia",
  "michelle", "stephanie", "claire", "kathleen", "jasmine", "tanya",
  "mika", "natalia",
  # invalid responses
  "barbell snatch", "bank of america", "easy", "empire building", "chill", "chinn", "webside",
  "finished", "flexibility", "health", "hot cold",
  "lazy", "low", "cliaire", "feelings", "too small", "Too small",
  "public", "ripe", "silent", "baked", "burn", "more costly", "exacting",
  # filter out the sentences without a CC
  "A bottle of wine at a liquor store was expensive", "A piece of cotton in craft shop was light", "A piece of plastic in hardware store was soft",
  "A spider in an insect terrarium was big", "At the butchershop the chicken was expensive", "At the conference center it was noisy when she met her friend", "during the night its light out there",
  "hears the cry of a crow", "In Aquarium a tuna was big", "In botanical garden an alpine tree was short.", "In summer that day was cold", "In the freezer michelle hand was cold", "it has a lot of stuff",
  "It was noisy in the nearby city", "its not a hot and cold", "move furniture through the front gate of her house", "picks up a piece of silk.", "the coat is light in weight", "	The coat of poodle was dark",
  "the color of the script is light", "the daisy is dark in color", "The first bite of her ice cream was warm", "The first sip of juice was cold", "The furniture was narrow at the back door of his house", "The new place rental rate is expensive", "the pair of sandals are expensive", "	The piece of silk is light.",
  "the sound of the shower is strong", "The statue made of plastic was cheap", "the walls of the condo are strong", "While walking heard the cry of a rooster when it was quiet", "Basketball player was tall",
  "Friend's new rowboat was fast", "Friend's new smartcar is big", "his favorite poem was short", "it is not destructive", "it is not loud", "it is not sold expensively", "it s not wide", "its noisy in here",
  "its not a soft", "On Saturday it was cold", "STRIP MALL IS SHORT", "summer days are warm", "That baby was loud", "the adult walk quickly", "The airplane is slow.", "The bird is loud.", "the car drives by quietly", "the car is quite", "the child is not fussy", "The child walks slow.", "The coat of poodle was dark", "large", "lengthy", "Little",
  "the color is not much", "the day is cold", "the dog's body is long", "The environment is quiet.", "the floor is soft", "The flower is short.", "the food is expensive", "the fruit cake was light", "the information is  long", "The mall is short.", "The mattress s firm", "the melon was soft", "the mouse is small", "the pages are not many", "the pencil color is light", "The piece of silk is light.", "The country lane was narrow", "The new place rental rate is expensive.", "The poodle's coat is light.", "the powerboat makes no noise", "the rabbit is fast", "the sneakers are costly", "the statue is cheap", "the street is wide", "The weather is cold today.", "The suit was expensive", "The trash is light.", "The watermelon was light", "A rock concert was loud", "little",
  "the movie i hope", "all light of off", "sits on a blanket", "try a new water color",
  "driving on a downtown street", "The spider was small", "The music was Loud",
  "powerboat sound little quiet", "Horn was too loud", "Villa price was costly",
  "choral consert was too loud", "milkshake was so hot", "strip mall was tall",
  "plastic was so soft", "pork was too expensive", "price of raspberries expensive",
  "coat of a spaniel was little light", "village area was too quit to read",
  "elderly person was too quick", "conference room was too quiet", "instant pot was slow",
  "tile floor was soft", "chocolate cake color was too dark", "marshmallow was soft for eat",
  "Blue paint is dark", "pick-ip truck was long", "sits on a bedboard.", "tails on mice",
  "they are bold", "the blade spinning", "its finished", "not sure", "too slow",
  "black", "boiling", "coat of paints", "Empire State Building", "glare", "indvidual experience", "information", "It is not loud", "It was night", "It was strong", "itrs warm", "its hot", "its low", "its low cost", "its not hard", "its not mute", "its not slow", "its not soft", "its not speed", "its too sound", "its wide", "lengthy", "less wide", "melting", "More costly", "move", "muscles", "pcks", "Relationship", "sexy", "Silent", "the duration", "the distance", "the have muscles", "they are fit", "they run fast", "thrill", "though", "Very slow", "walking outside", "walking assistance tools", "word", "worthy", "tough", "picks up their trash can.", "all lights off", "amount", "high", "its long", "it cooks quickly", "little", "outside"
)
```

Simple (invalid) copular sentences including no comparison classes are constructed and excluded together with the invalid responses above.

``` {r excludeInvalidResps}
# excluding invalid responses
d.tidy.resps.catch <- df.trials.filtered %>%
  filter((grepl("it's", response, ignore.case = T) |
    grepl("they're", response, ignore.case = T)))

# get invalid responses which are full sentences without any comparison class
d.tidy.resp.valid <- anti_join(
  df.trials.filtered,
  d.tidy.resps.catch
) %>%
  rowwise() %>%
  mutate(
    stopPhrase = paste("the", np, "is", adj, sep = " "),
    stopPhrase2 = paste("the", np, "is",
      paste(adj, ".", sep = ""),
      sep = " "
    ),
    responseLength = lengths(str_split(response, " "))
  ) %>%
  filter((tolower(response) != stopPhrase) &
    (tolower(response) != stopPhrase2))

# get the long responses that were not matched above and filter them out manually
# d.tidy.resp.valid.resps %>% filter(responseLength >= 4) %>% View()

d.tidy.resp.valid <- d.tidy.resp.valid %>%
  rowwise() %>%
  # exclude responses which excatly match the ones in the following list
  subset(., !(response %in% invalid.responses))

n.valid.responses <- d.tidy.resp.valid %>%
  ungroup() %>%
  count() %>%
  pull(n)

n.total.responses - n.valid.responses

```

### "Similar"

We further exclude responses that used the word "similar"; we deemed these responses too underspecified (how similar is similar?). These numbered only 15 in total.


```{r remove similar}
d.tidy.auto %>%
  filter(grepl("similar", response_lemma, ignore.case = T)) -> d.uncertain.resps # 15 responses

d.tidy.resp.valid.no_similar <- anti_join(
  d.tidy.resp.valid,
  d.uncertain.resps
)
```


## Basic Corrections: Misspellings, Lemmatization, Synonyms

### Misspelling Correction

In order to improve matching of the provided repsonses to the subordinate NPs or the anticipated superordinate labels, we correct misspellings occurring in the provided responses. The misspellings were extracted manually. The misspellings and corrections are read from the dataframe and converted to a named list which is used with str_replace_all. 

```{r list of commong mispellings}
misspellings_df <- read_csv("text_processing/misspellings_dict.csv")
misspellings_set <- pull(misspellings_df, V2) %>% set_names(pull(misspellings_df, V1))
```


### Lemmatization 

To further improve the response classification, we lemmatize the plural responses (specifically, the irregular nouns and misspellings) to match the NPs and superordinates (e.g. 'libraries' is converted to 'library').

```{r list of lemmatizations}
# mostly Plural --> singulars
lemmatization_df <- read_csv("text_processing/lemmatization_dict.csv")
lemmatization_set <- pull(lemmatization_df, V2) %>% set_names(pull(lemmatization_df, V1))
```

### Synonym Extraction

To further improve the response classification, we also replace some raw responses which are obviously synonymous to the provided subordinate or superoridnate NPs given the context (e.g. 'automobile' is converted to 'car') .
```{r list of common synonyms}
synonym_df <- read_csv("text_processing/synonym_dict.csv")
synonym_set <- pull(synonym_df, V2) %>% set_names(pull(synonym_df, V1))
```


```{r apply corrections}
d.tidy.resp.valid.no_similar %>%
  mutate(response = as.character(response)) %>%
  ungroup() %>%
  mutate(
    response_spelling = str_replace_all(tolower(response), misspellings_set),
    response_synonym = str_replace_all(response_spelling, synonym_set),
    response_lemma = tolower(str_replace_all(response_synonym, lemmatization_set))
  ) %>%
  mutate(
    corrected_spelling = response != response_spelling,
    corrected_synonym = response_spelling != response_synonym,
    corrected_lemma = response_synonym != response_lemma
  ) -> d.tidy.resp.valid.lemmatized

sum(d.tidy.resp.valid.lemmatized$corrected_spelling)
sum(d.tidy.resp.valid.lemmatized$corrected_spelling) / n.valid.responses
sum(d.tidy.resp.valid.lemmatized$corrected_synonym)
sum(d.tidy.resp.valid.lemmatized$corrected_synonym) / n.valid.responses
sum(d.tidy.resp.valid.lemmatized$corrected_lemma)
sum(d.tidy.resp.valid.lemmatized$corrected_lemma) / n.valid.responses
```


## Match keyword(s) in Responses

For automated checking of whether or not responses contain the supplied NP (i.e. are subordinate) or the anticipated superordinate of the item (i.e. are superordinate), we distill multi-word NPs (e.g., "six-pack of beer") to single words (e.g., "beer") that we think convey the essence of the subordinate category given the context. And so, if we see a response containing the word "beer", then it will be marked as *specific* (i.e., including the mentioned NP). 

```{r np match}
d.tidy.resp.valid.lemmatized.np_match <- d.tidy.resp.valid.lemmatized %>%
  rowwise() %>%
  mutate(
    np_match = tolower(np), # additional column where we put the NP to be matched against, such that the original NPs can be accessed if necessary
    np_match = gsub("bottle of top-shelf liquor", "liquor", np_match),
    np_match = gsub("piece of chocolate", "chocolate", np_match),
    np_match = gsub("piece of chalk", "chalk", np_match),
    np_match = gsub("six-pack of beer", "beer", np_match),
    np_match = gsub("bottle of wine", "wine", np_match),
    np_match = gsub("pine tree", "pine", np_match),
    np_match = gsub("redwood tree", "redwood", np_match),
    np_match = gsub("alpine tree", "alpine", np_match),
    np_match = gsub("bonsai tree", "bonsai", np_match),
    np_match = gsub("pick-up truck", "pick-up", np_match),
    np_match = gsub("relay race", "relay", np_match),
    np_match = gsub("triathlon race", "triathlon", np_match),
    np_match = gsub("sprinting race", "sprint", np_match),
    np_match = gsub("kettle ball", "ball", np_match),
    np_match = gsub("study hall", "study", np_match),
    np_match = gsub("electric car", "electric", np_match),
    np_match = gsub("bass guitar", "bass", np_match),
    np_match = gsub("choral concert", "choral", np_match),
    np_match = gsub("rap concert", "rap", np_match),
    np_match = gsub("white paint", "white", np_match),
    np_match = gsub("blue paint", "blue", np_match),
    np_match = gsub("black paint", "black", np_match),
    np_match = gsub("limousine", "limo", np_match),
    np_match = gsub("smartcar", "smart", np_match),
    np_match = gsub("japanese restaurant", "japanese", np_match),
    np_match = gsub("chinese restaurant", "chinese", np_match),
    np_match = gsub("korean restaurant", "korean", np_match),
    np_match = gsub("elderly person", "elder", np_match),
    np_match = gsub("oil paint", "oil", np_match),
    np_match = gsub("wall paint", "wall", np_match),
    np_match = gsub("shopping mall", "mall", np_match),
    np_match = gsub("chocolate fondue", "fondue", np_match),
    np_match = gsub("cell phone", "phone", np_match),
    np_match = gsub("bear den", "bear", np_match),
    np_match = gsub("fox den", "fox", np_match),
    np_match = gsub("mouse den", "mouse", np_match),
    np_match = gsub("downtown street", "downtown", np_match),
    np_match = gsub("side road", "side", np_match),
    np_match = gsub("back door", "back", np_match),
    np_match = gsub("patio door", "patio", np_match),
    np_match = gsub("front gate", "front", np_match),
    np_match = gsub("chocolate cake", "chocolate", np_match),
    np_match = gsub("podcast episode", "podcast", np_match)
  )
```


# Automatic Classification

The preprocessed responses are automatically classified into subordinate and superordinate by matching them against the preprocessed subordinate keywords and superordinates. We check if the response includes either the keyword or the superordinate and if either includes the response. Furthermore, since we check either way and some NPs are composites including the superordinate, we manually check if the response is just the superordinate ('berries') and classify it as the superordinate accordingly. 

```{r check if response contains sub/super and visa versa}
d.tidy.resp.valid.lemmatized.np_match %>%
  rowwise() %>%
  mutate(
    response_lemma = as.character(response_lemma),
    cleanedPhrase = paste("_", as.character(response_lemma), "_", sep = ""), # add buffer to allow for split to occur at beginning or end
    np_match = as.character(np_match),
    np_match = gsub('\"', "", np_match),
    np_match_us = paste("_", np_match, "_", sep = ""), # insert underscores for the matching the other way around
    super_us = paste("_", superordinate, "_", sep = ""),
    # check if response and seed NP match
    specific = # ifelse(
    # catch these responses because otherwise classified as subordinate for "strawberries" etc
    ifelse(response_lemma == "berries", 0,
      containsString_responses(
        as.character(cleanedPhrase),
        np_match,
        response_lemma,
        np_match_us
      )
    ),
    # check if response and anticipated superordinate match
    matchingSuper = containsString_responses(
      as.character(cleanedPhrase),
      as.character(superordinate),
      response_lemma,
      super_us
    )
  ) -> d.tidy.auto

# extract the automatically matched data (out of 26.552 responses (post exclusion) 22.117 are matched )
d.tidy.auto.match <- d.tidy.auto %>%
  filter((specific == 1) | (matchingSuper == 1))


n.automatic.responses <- d.tidy.auto.match %>%
  ungroup() %>%
  count() %>%
  pull(n)

n.automatic.responses
n.automatic.responses / n.valid.responses
```

Responses for items that were classified as all subordinate or superordinate (mean = 0 or 1) are double-checked.

```{r check ceiling/floor responses}
# check the matched items where the mean of responses is 1 or 0
d.tidy.auto.match %>%
  group_by(stim_id, np_expectations, adj_polarity) %>%
  mutate(meanResp = mean(specific)) %>%
  filter((meanResp == 1) | (meanResp == 0)) %>%
  distinct(
    stim_id, np_expectations,
    np_match, adj_polarity, adj,
    response_lemma, # showing response_lemma will show the individual (lemmatized) responses that were all categorized as either sub or super
    meanResp
  ) -> d.match.ceiling
  
d.match.ceiling %>%
  distinct(stim_id, np_expectations, adj_polarity, meanResp) %>%
  group_by(meanResp) %>%
  count()

d.match.ceiling %>%
  ungroup() %>%
  distinct(
    stim_id, np_expectations,  
    np_match, adj,
    meanResp
  ) %>%
  sample_n(20) %>%
  kable()
  #View()

d.match.ceiling %>%
  ungroup() %>%
  filter(meanResp == 1) %>%
  distinct(
    stim_id, np_expectations,  
    np_match, adj_polarity,
    meanResp
  ) %>%
  group_by(np_expectations, adj_polarity) %>%
  count() %>%
  ungroup() %>%
  mutate(np_expectations = factor(np_expectations, levels = c("low", "medium", "high"))) %>%
  rename(adjpol = adj_polarity) %>%
  spread(np_expectations, n) %>% 
  kable()
  # write_csv(., "../../writing/paper/csv_data_4_tex/itemCounts_ceil_floor.csv")
```

## Post-processing of Automatically Classified Data

After we manually inspected the data with respect to superordinate responses that systematically deviated from the anticipated ones, we modified one item (77 "desserts") for which the superordinate deviated (participants tended to paraphrase the more general class as "food"). We use the empirical modal superordinate ("food") for the frequency extraction and the adjective endorsement task. 
If the response was classified as subordinate (i.e. _specific_), it is turned into be the corresponding NP (represented by the variable `mode_np`), otherwise it is turned into the corresponding superordinate.

``` {r}
d.tidy.auto.no_similar.match.adjust_super <- d.tidy.auto.match %>%
  mutate(
    # substitutions made based on human modal responses
    superordinate = ifelse(stim_id == 77, "food", superordinate)
  ) %>%
  # if the response is specific (subordinate), the modal NP is inserted, otherwise the modal superordinate is inserted
  mutate(mode_np = ifelse(specific == 1, np, superordinate))
```

### Frequencies

```{r plural np for freq}
# this function takes the raw NPs that we use in the experiment, e.g. 'six-pack of beer' (not the substituted key-words, e.g.,  beer, that we used for automatic categorization) to create the respective plural NPs we use for frequencies
insert_plural_np <- function(np, superordinate) {
  if (np %in% c("piece of chocolate")) {
    np_pl <- "chocolates"
  } else if (np %in% c("piece of chalk")) {
    np_pl <- "chalks"
  } else if (np %in% c("story")) {
    np_pl <- "stories"
  } else if (np %in% c("daisy")) {
    np_pl <- "daisies"
  } else if (np %in% c("library")) {
    np_pl <- "libraries"
  } else if (np %in% c("party")) {
    np_pl <- "parties"
  } else if (np %in% c("bush")) {
    np_pl <- "bushes"
  } else if (np %in% c("finch")) {
    np_pl <- "finches"
  } else if (np %in% c("pansy")) {
    np_pl <- "pansies"
  } else if (np %in% c("documentary")) {
    np_pl <- "documentaries"
  } else if (np %in% c("pantry")) {
    np_pl <- "pantries"
  } else if (np %in% c("choral concert")) {
    np_pl <- "choirs"
  } else if (np %in% c("elderly person")) {
    np_pl <- "elderly people"
  } else if (np %in% c("mouse")) {
    np_pl <- "mice"
  } else if (np %in% c("church")) {
    np_pl <- "churches"
  } else if (np %in% c("tile")) {
    np_pl <- "tile floors"
  } else if (np %in% c("wood") & (superordinate == "floors")) {
    np_pl <- "wood floors"
  } else if (np %in% c("carpet") & (superordinate == "floors")) {
    np_pl <- "carpet floors"
  } else if (np %in% c("summer")) {
    np_pl <- "summer days"
  } else if (np %in% c("fall")) {
    np_pl <- "fall days"
  } else if (np %in% c("winter")) {
    np_pl <- "winter days"
  } else if (np %in% c("couch")) {
    np_pl <- "couches"
  } else if (np %in% c("tomato")) {
    np_pl <- "tomatoes"
  } else if (np %in% c("jolly rancher")) {
    np_pl <- "jollies"
  } else if (np %in% c("peach")) {
    np_pl <- "peaches"
  } else if (np %in% c("city")) {
    np_pl <- "cities"
  } else if (np %in% c("auditorium")) {
    np_pl <- "auditoria"
  } else if (np %in% c("bottle of top-shelf liquor")) {
    np_pl <- "liquors"
  } else if (np %in% c("six-pack of beer")) {
    np_pl <- "beers"
  } else if (np %in% c("bottle of wine")) {
    np_pl <- "wine bottles"
  } else if (np %in% c("bush")) {
    np_pl <- "bushes"
  } else if (np %in% c("mouse den")) {
    np_pl <- "mouse holes"
  } else if (np %in% c("sprinting race")) {
    np_pl <- "sprints"
  } else if (np %in% c("child")) {
    np_pl <- "children"
  } else if (np %in% c("baby")) {
    np_pl <- "babies"
  } else if (np %in% c("platinum")) {
    np_pl <- "platinum statue"
  } else if (np %in% c("bronze")) {
    np_pl <- "bronze statues"
  } else if (np %in% c("pick-up truck")) {
    np_pl <- "pick up trucks"
  } else if ((np %in% c("plastic")) & (superordinate == "bracelets")) {
    np_pl <- "plastic bracelets"
  } else if (np %in% c("gold")) {
    np_pl <- "gold bracelets"
  } else if (np %in% c("metal")) {
    np_pl <- "metal bracelets"
  } else if ((np %in% c("plastic")) & (superordinate == "statues")) {
    np_pl <- "plastic statues"
  } else if (np %in% c(
    "wool", "wood", "fish", "ice cream", "garlic", "saffron", "coffee", "raspberries",
    "boysenberries",
    "strawberries", "sneakers", "chicken", "boots", "tuna", "pork", "sandals", "plastic", "instant pot"
  )) {
    np_pl <- np # the items left singular
  } else {
    np_pl <- paste(np, "s", sep = "")
  }
  return(np_pl)
}
```


We extract frequecies of the plural NPs and the adjusted superordinates from the Google Web 1T 5-gram corpus (except for some items). We exchange some superordinates for their synonyms in order avoid polysemy. 

```{r}
d.tidy.auto.classified.w.pl.np <- d.tidy.auto.no_similar.match.adjust_super %>%
  rowwise() %>%
  mutate(
    np_pl = insert_plural_np(tolower(np), superordinate),
    superordinate.freq = superordinate,
    superordinate.freq = ifelse(stim_id == 90, "doors", superordinate.freq),
    superordinate.freq = ifelse(stim_id == 5, "writing tools", superordinate.freq),
    superordinate.freq = ifelse(superordinate == "venue", "venues", superordinate.freq),
    superordinate.freq = ifelse(superordinate == "dens", "animal dens", superordinate.freq) # avoid polysemy
  )

```

The corresponding subordinate and superordinate frequencies are added to each data point. 

```{r}
df.frequencies <- read_csv("../data/class-elicitation-prereg-final/class-elicitation-final-plural_frequencies.csv")

d.tidy.auto.classified.w.frequency <- d.tidy.auto.classified.w.pl.np %>%
  left_join(., df.frequencies, by = c("np_pl" = "NPs")) %>% # add subordinate frequencies
  left_join(., df.frequencies, by = c("superordinate.freq" = "NPs")) %>% # add superordinate frequencies
  mutate(
    degree = ifelse(degree == "length_duration", "length", degree)
  )

df.mode.auto.final <- d.tidy.auto.classified.w.frequency %>%
  select(
    workerid, stim_id, degree, superordinate.freq, adj, adj_polarity,
    np, np_pl, np_expectations, mode_np, specific, Frequencies.x, Frequencies.y
  ) %>%
  mutate(
    superordinate_pl = superordinate.freq, NP_sg = np, NP_pl = np_pl,
    response = mode_np, subFreq = Frequencies.x, superFreq = Frequencies.y
  ) %>%
  select(
    workerid, stim_id, degree, superordinate_pl, adj, adj_polarity,
    NP_sg, NP_pl, np_expectations, response, specific, subFreq, superFreq
  )

# write_csv(df.mode.auto.final, "../data/class-elicitation-prereg-final/auto-classified-data-w-freqs-final.csv")
```



## Manual Response Processing 

We look at the responses that were not automatically classified (about 4000). We judge if the deviating responses are synonymous to our experimentally-supplied NPs or anticipated superordinates and adjust them in order to match to those NPs or superordinates. Deviant responses which occur frequently are left unchanged to check if any deviating response was the modal response for any particular NP-adj pair.

``` {r nonMatchedResps}
# look at the unique non-matched responses
d.tidy.auto.non_match <- anti_join(d.tidy.auto, d.tidy.auto.no_similar.match)

length(d.tidy.auto.non_match$response)

# d.tidy.auto.non_match %>%
#   distinct(superordinate, np, context_sentence, adj, np_match, response, response_lemma, cleanedPhrase, specific, matchingSuper) %>%
#   View()
```

First, we further lemmatize the non-matching responses and correct for misspellings to extract the responses which were produced by at least 3 participants for the respective stimulus (NP-adj pair). 

The responses are lower-cased. The lemmatization and misspelling correction is read into a dataframe and converted into a named list to use with `str_replace_all`. 

MH: Why can't we do the misspelling replacement (and lemmatization) with the other misspellings and lemmatizations above?

``` {r nonMatchedResps-lemmatize}
d.tidy.auto.non_match <- d.tidy.auto.non_match %>%
  mutate(response = tolower(response))

# this will be removed after the classification is finalised
hand_class_lemmatization <- c("colour", "colors", "\\.", ",", "other\\s", "furs", "forrest", "apartmet", "aquariums", "athelete", "banks", "bird's", "bodys", "bouqet", "bouquets", "boxes", "boxs", "butchershop", "building\\b", "car's", "car\\b", "chacolate", "childern", "chocholate", "chocolates", "cloths", "can\\b", "coffe", "crying", "day's", "day\\b", "decor\\b", "decors", "den's", "deserts", "desswerts", "dinners", "distances", "dog's", "environments", "envrionments", "fabrics", "foods", "forests", "friends", "fruits", "furnitures", "gates", "map\\b", "highways", "houses", "human beings", "illunation", "inatruments", "\\binks", "terrariums", "instruents", "instuments", "store", "jewelery", "jewlery", "kitchens", "lakes", "mall's", "malls", "mattresses", "menus", "metals", "movies", "music instrument", "instrument\b", "nights", "noises", "papers", "parks", "furnature", "place\\b", "prices", "products", "restaraunts", "roads", "rooms", "runnres", "saturday's", "saturdays", "scipts", "script\\b", "script's", "scripts'", "sound\\b", "street\\b", "stringed", "\\bthe\\s", "temperatures", "terrarium's", "weght", "of the day", "tkime", "truck\\b", "weights")

hand_class_replacements <- c("color", "color", "", "", "", "fur", "forest", "apartment", "aquarium", "athlete", "bank", "birds", "bodies", "bouquet", "bouquet", "box", "box", "butcher shop", "buildings", "cars", "cars", "chocolate", "children", "chocolate", "chocolate", "clothes", "cans", "coffee", "cries", "days", " days", "decoration", "decoration", "dens", "desserts", "desserts", "dinner", "distance", "dog", "environment", "environment", "fabric", "food", "forest", "friend", "fruit", "furniture", "gate", "maps", "highway", "house", "humans", "illumination", "instruments", "ink", "terrarium", "instruments", "instruments", "shop", "jewelry", "jewelry", "kitchen", "lake", "mall", "mall", "mattress", "menu", "metal", "movie", "musical instrument", "instruments", "night", "noise", "paper", "park", "furniture", "places", "price", "product", "restaurants", "road", "room", "runners", "saturday", "saturday", "scripts", "scripts", "scripts", "scripts", "sounds", "streets", "string", "", "temperature", "terrarium", "weight", "of day", "time", "trucks", "weight")
# cbind(hand_class_lemmatization, hand_class_replacements) %>% as.data.frame() %>% write_csv(., '../data/class-elicitation-prereg-final/hand_classification_lemmatization_dict.csv')

# apply lematizations
hand_class_lemmatization_df <- read_csv("text_processing/hand_classification_lemmatization_dict.csv") %>%
  rowwise() %>%
  mutate(
    hand_class_replacements = ifelse(is.na(hand_class_replacements), "",
      hand_class_replacements
    )
  )

hand_lemmatization <- pull(
  hand_class_lemmatization_df,
  hand_class_replacements
) %>%
  set_names(pull(hand_class_lemmatization_df, hand_class_lemmatization))

# MH: I would write hand_lemmatization to a file and just read it in here...

d.tidy.auto.non_match <- d.tidy.auto.non_match %>%
  mutate(
    response_lemma = as.character(response_lemma),
    response = as.character(response),
    response_hand_lemma = str_replace_all(response, hand_lemmatization)
  )
```

The lemmatized and corrected reponses are counted by-stimulus; we keep those which were produced by at least 3 participants. 890 non-matched responses (20.7%) were produced less than 3 times and are dropped. 

``` {r nonMatchedResps-grab3}
# d.tidy.auto.non_match.lemma.counts <- d.tidy.auto.non_match %>% count(stim_id, response_hand_lemma)

# MH, I found it illuminating to look at: d.tidy.auto.non_match %>% count(response_hand_lemma) %>% View()
# you can see if there are more misspellings or lemmatizations required easily by sorting by response_hand_lemma 

# d.tidy.auto.non_match.grab3 <- d.tidy.auto.non_match.lemma.counts %>%
#   right_join(., d.tidy.auto.non_match, by = c("stim_id", "response_hand_lemma")) %>%
#   filter(n >= 3)
# MH: this code replaces the need for the other two lines above this

d.tidy.auto.non_match.grab3 <- d.tidy.auto.non_match %>% 
  group_by(stim_id, response_hand_lemma) %>% 
  mutate(n = n()) %>% 
  filter(n >= 3)

nrow(d.tidy.auto.non_match) - nrow(d.tidy.auto.non_match.grab3)
(nrow(d.tidy.auto.non_match) - nrow(d.tidy.auto.non_match.grab3)) / nrow(d.tidy.auto.non_match)
```

Some responses fail to establish correct reference, e.g. participants referred to the wrong entity mentioned in the context sentence: given the sentence "John sees an adult lift a box" and the comment "John says: 'They're strong'", when asked who the adult is strong relative to, some subjects responded "relative to other boxes". Since these 'failed-reference' responses often mention distractor nouns in the context sentence, we extract these responses by looking for content words from the contexts. 

Simply mentioning another noun in the context sentence is not tantamount to 'reference failure'. For example, some items mention the dimension that the adjective describes (e.g., "the color of a dog"), which would still make appropriate comparison classes (e.g., "dark relative to other fur colors").
We thus keep some responses grabbed by this approach on an item-by-item basis.

``` {r}
# remove stop words from context sentences
d.tidy.auto.non_match.grab3.removeStopWords <- d.tidy.auto.non_match.grab3 %>%
  mutate(clean_context_sentence = as.character(context_sentence)) %>%
  unnest_tokens(word, clean_context_sentence) %>%
  anti_join(., stop_words, by = ("word")) %>%
  group_by(workerid, trial_num) %>%
  mutate(wordNumber = paste("word_", row_number(), sep = "")) %>%
  spread(wordNumber, word) %>%
  unite(clean_context_sentence, starts_with("word_"), sep = " ") %>%
  mutate(clean_context_sentence = gsub(" NA", "", clean_context_sentence))

# check if response is in the cleaned context sentence

d.tidy.auto.non_match.grab3.failedRef <- d.tidy.auto.non_match.grab3.removeStopWords %>%
  mutate(resps_matching_context = as.character(response_hand_lemma)) %>%
  unnest_tokens(word, resps_matching_context) %>%
  filter(grepl(word, clean_context_sentence, fixed = T)) %>% # MH: I THINK THIS IS MISSING PLURALS (e.g., the first row of this df is about "scripts", but the context sentence only has the word "script" in it)
  group_by(workerid, trial_num) %>%
  mutate(wordNumber = paste("word_", row_number(), sep = "")) %>% # MH: What is the purpose of this? It looks like you matching sometimes multiple words in a sentence (e.g., "google maps"). Is this to keep that straight so you don't double count?
  spread(wordNumber, word) %>%
  unite(resps_matching_context, starts_with("word_"), sep = " ") %>%
  mutate(resps_matching_context = gsub(" NA", "", resps_matching_context)) %>% # MH: I examined responses at this point..
  # filter out manually responses not be dropped
  filter(!(
    (resps_matching_context == "color") |
      (resps_matching_context == "coat") |
      (response_hand_lemma == "mall") |
      (response_hand_lemma == "fur") |
      (response_hand_lemma == "fur color") |
      (response_hand_lemma == "restaurant") |
      (response_hand_lemma == "person") |
      (response_hand_lemma == "paint color") |
      (response_hand_lemma == "places to live") |
      (response_hand_lemma == "places for dinner") |
      (response_hand_lemma == "parts of kitchen") |
      (response_hand_lemma == "chocolate") |
      (response_hand_lemma == "electronics")
  ))
```

The reference-failing responses are excluded (404 responses). Other responses are classified using a dictionary of manual classification read from a dataframe:

``` {r nonMatched-dropFailedRef}
d.tidy.auto.non_match.grab3.noFailedRef <- d.tidy.auto.non_match.grab3 %>%
  anti_join(., d.tidy.auto.non_match.grab3.failedRef, by = c("stim_id", "response_hand_lemma"))

nrow(d.tidy.auto.non_match.grab3) - nrow(d.tidy.auto.non_match.grab3.noFailedRef)
```
The data without reference-failed responses is manually classified into the following types of comparison classes:
- subordinate ('sub')
- superordinate ('super')
- super-superordinate ('supersuper'): comparison classes that are more general than the anticipated superordinate categories (e.g. 'things' relative to the anticipated 'musical instruments')
- different hierarchy ('diff'): the comparison class is outside of the anticipated hierarchy (e.g. more specific than the anticipated superordinate: "cats" instead of animals for stim 8)
- "NA" for invalid responses 

The by-response hand-classifications are put into the column 'hand_cc'.

Most classifications are read from a dataframe and are classifications from a produced response (a string) to a categorization. Some of these judgments are adjective-NP (item) specific, and these are performed after reading the dataframe with `case_when`. 

``` {r manualCC}
# look at distinct responses
d.tidy.auto.non_match.grab3.noFailedRef %>%
  distinct(stim_id, superordinate, np, adj, response_hand_lemma) %>%
  View()

# here the data frame of the dictionary with the classifications for `str_replace_all` is created for those responses which are classified individually
# it will be removed when classification is set
# responses where the calssification depends on the specific item are post-processed with `case_when`
hand_cc_lemma <- c(
  "animals", "apartments", "areas", "athletes", "beds", "beverages", "bikes", "bird sounds", "birds", "bodies of water", "bottles", "buildings", "cans", "cars", "cats", "centers", "children", "chocolate", "cities", "cloth", "clothes", "coat", "coat color", "coats", "color", "color of scripts", "condiments", "cooking appliances", "cooking methods", "days", "decorations", "desserts", "dishes", "distance", "dog coats", "doors", "drinks", "electronics", "environment", "episodes", "evenings", "fabric", "films", "food", "fruit", "fur", "fur color", "habitats", "holes", "homes", "house", "indoor spaces", "ink", "ink color", "instruments", "items", "jewelry", "kids", "lanes", "lifters", "liquids", "locations", "mall", "materials", "mattress", "meals", "melons", "metal", "methods", "methods of cooking", "motors", "movie", "music", "musical instruments", "night", "noise", "objects", "openings", "paint color", "paintings", "pans", "paper", "parts of kitchen", "people", "performances", "person", "places", "places for dinner", "places to live", "planes", "plants", "players", "pots", "price", "product", "programs", "restaurants", "rinks", "rivers", "road", "rodents", "room", "routes", "runners", "scripts", "scripts color", "seats", "shades", "shops", "shows", "smells", "songs", "sounds", "spaces", "stoves", "streets", "string instruments", "structures", "temperature", "things", "things in sky", "towns", "traffic", "trucks", "tv shows", "vegetables", "vehicles", "venues", "walkers", "walks", "walkways", "weather", "weightlifters"
)
hand_cc <- c(
  "supersuper", "sub", "sub", "diff", "sub", "diff", "sub", "super", "diff", "super", "sub", "super", "diff", "super", "diff", "super", "sub", "diff", "diff", "diff", "diff", "sub", "sub", "sub", "sub", "sub", "supersuper", "super", "super", "super", "supersuper", "diff", "super", "NA", "super", "super", "diff", "super", "supersuper", "super", "diff", "super", "super", "supersuper", "supersuper", "sub", "sub", "supersuper", "super", "sub", "sub", "supersuper", "sub", "sub", "supersuper", "supersuper", "supersuper", "sub", "sub", "NA", "supersuper", "super", "super", "super", "sub", "NA", "super", "diff", "super", "super", "diff", "super", "diff", "supersuper", "super", "supersuper", "supersuper", "supersuper", "sub", "diff", "super", "diff", "super", "supersuper", "supersuper", "super", "super", "supersuper", "super", "super", "supersuper", "diff", "super", "NA", "supersuper", "super", "NA", "sub", "super", "NA", "diff", "diff", "diff", "sub", "diff", "sub", "diff", "sub", "NA", "super", "diff", "diff", "diff", "supersuper", "diff", "super", "supersuper", "supersuper", "diff", "supersuper", "supersuper", "super", "diff", "super", "super", "NA", "supersuper", "super", "diff", "super", "diff", "NA"
)
# cbind(hand_cc_lemma, hand_cc) %>% as.data.frame() %>% write_csv(., '../data/class-elicitation-prereg-final/hand_comp_classes_dict.csv')

hand_cc_dict <- read_csv("../data/class-elicitation-prereg-final/hand_comp_classes_dict.csv") %>%
  rowwise() %>%
  mutate(
    hand_cc = ifelse(is.na(hand_cc), "NA", hand_cc)
  )

hand_cc_df <- pull(
  hand_cc_dict,
  hand_cc
) %>%
  set_names(pull(hand_cc_dict, hand_cc_lemma))

d.auto.non_match.hand_cc <- d.tidy.auto.non_match.grab3.noFailedRef %>%
  mutate(
    hand_cc = str_replace_allll(response_hand_lemma, hand_cc_df)
  ) %>%
  # rowwise() %>%
  mutate(
    hand_cc =
      65(
        response_hand_lemma == "appliances" & stim_id == 61 ~ "supersuper",
        response_hand_lemma == "appliances" & stim_id == 75 ~ "diff",
        response_hand_lemma == "cans" & stim_id == 81 ~ "sub",
        response_hand_lemma == "color" & stim_id == 2 ~ "supersuper",
        response_hand_lemma == "color" & stim_id == 70 ~ "diff",
        response_hand_lemma == "color" & stim_id == 2 ~ "supersuper",
        response_hand_lemma == "days" & stim_id == 76 ~ "diff",
        response_hand_lemma == "days" & stim_id == 77 ~ "diff",
        response_hand_lemma == "days" & stim_id == 72 ~ "diff",
        response_hand_lemma == "days" & stim_id == 73 ~ "diff",
        response_hand_lemma == "desserts" & stim_id == 3 ~ "supersuper",
        response_hand_lemma == "fabric" & stim_id == 13 ~ "diff",
        response_hand_lemma == "food" & stim_id == 50 ~ "diff",
        response_hand_lemma == "fruit" & stim_id == 9 ~ "NA",
        response_hand_lemma == "locations" & stim_id == 38 ~ "NA",
        response_hand_lemma == "person" & stim_id == 69 ~ "supersuper",
        response_hand_lemma == "places" & stim_id == 4 ~ "diff",
        response_hand_lemma == "places" & stim_id == 38 ~ "NA",
        response_hand_lemma == "places" & stim_id == 29 ~ "supersuper",
        response_hand_lemma == "places" & stim_id == 39 ~ "NA",
        response_hand_lemma == "places" & stim_id == 31 ~ "NA",
        response_hand_lemma == "places" & stim_id == 42 ~ "supersuper",
        response_hand_lemma == "room" & stim_id == 75 ~ "NA",
        response_hand_lemma == "room" & stim_id == 35 ~ "NA",
        response_hand_lemma == "room" & stim_id == 11 ~ "NA",
        response_hand_lemma == "streets" & stim_id == 37 ~ "NA",
        response_hand_lemma == "weather" & stim_id == 76 ~ "NA",
        response_hand_lemma == "weather" & stim_id == 76 ~ "NA",
        TRUE ~ hand_cc
      )
  )

# drop the invalid responses classified as "NA"
d.auto.non_match.hand_cc.valid <- d.auto.non_match.hand_cc %>% filter(!(hand_cc == "NA"))
```


The adjustments are read from the data frame and converted to a named list ot be used in str_replace_all.
```{r}
hand_classification_df <- read_csv("../data/class-elicitation-prereg-final/hand_classification_dict.csv") %>%
  rowwise() %>%
  mutate(V2 = ifelse(is.na(V2), "", V2))

hand_classification <- pull(hand_classification_df, V2) %>% set_names(pull(hand_classification_df, V1))
```

The hand-classified responses are then checked if they include the NP or the anticipated superordinate or vice versa. 

``` {r}
# replace the sketchy synonyms
d.tidy.auto.non_match.hand_classified <- d.tidy.auto.non_match.grab3.noFailedRef %>%
  mutate(
    response_hand_lemma = as.character(response_hand_lemma),
    response = as.character(response),
    response_lemma_hand = str_replace_all(
      response_hand_lemma,
      hand_classification
    )
  ) %>%
  mutate(
    cleanedPhrase = paste("_", as.character(response_lemma_hand), "_", sep = ""),
    specific = containsString_responses(
      as.character(cleanedPhrase),
      as.character(np_match),
      response_lemma_hand,
      np_match_us
    ),
    matchingSuper = containsString_responses(
      as.character(cleanedPhrase),
      as.character(superordinate),
      response_lemma_hand,
      super_us
    )
  )

# none were classified as specific or super
d.tidy.auto.non_match.hand_classified %>%
  filter((specific == 1) | (matchingSuper == 1)) -> d.tidy.auto.non_match.hand_classified_match

# look at distinct responses for more detailed classification
d.tidy.auto.non_match.hand_classified %>%
  filter((specific == 0) & (matchingSuper == 0)) %>%
  distinct(stim_id, superordinate, np, adj, response_hand_lemma, response_lemma_hand) %>%
  View()
```

The responses which were still not classified are processed further. Some of the manual adjustments are made on an item-by-item basis. For example, we take paraphrases including the place or the time mentioned in the context sentence to mean the subordinate in e.g. cases like 'He heard an owl cry in the forest': The response "it's loud...compared to other forests' to mean 'owls in other forests'. 
Then, we again checked if the responses include the NP or the anticipated superordinate or if those include the response. 

``` {r}
d.tidy.auto.non_match.hand_classified %>%
  filter((specific == 0) & (matchingSuper == 0)) %>%
  rowwise() %>%
  mutate(
    response_lemma_hand = ifelse(superordinate == "cookware",
      gsub("pans", "frying pan", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "cookware",
      gsub("dinner", "cookware", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = gsub("illunation", np_match, response_lemma_hand),
    response_lemma_hand = gsub("illumination", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "desserts", gsub("chocolate", "chocolate fondue", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "furniture", gsub("beds", "bedboard", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "entertainment", gsub("films", "movie", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "waterways", gsub(
      "lake", np_match,
      response_lemma_hand
    ), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "vehicles", gsub("trucks", "pick-up", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "people", gsub("walks", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "times of day",
      ifelse(response_lemma == "day", np_match,
        response_lemma_hand
      ), response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "times of day",
      ifelse(response_lemma == "day", np_match, response_lemma_hand), response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "writing utensils", gsub("ink", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "birds", gsub("day", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "food", gsub("day", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "writing utensils", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "seasons", gsub("past day", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "insects", gsub("terrarium", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "buildings", gsub(
      "apartments", "apartment building",
      response_lemma_hand
    ), response_lemma_hand),
    response_lemma_hand = gsub("brands", np_match, response_lemma_hand),
    response_lemma_hand = gsub("butchershop", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "places", gsub("baths", "sauna", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(np == "bottle of wine", gsub("bottles", "wine", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "furniture", gsub("cans", "trash cans", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "animals", gsub("zoo", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "loudness", gsub("child", "baby", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "weight", gsub("children", "kid", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(np_match == "conference center", gsub("centers", "conference center", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "weight", gsub("childern", "kid", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "cakes", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "temperature_h", gsub(
      "chocolate", "chocolate fondue",
      response_lemma_hand
    ), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "darkness", gsub("duck", "dusk", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = gsub("compared store", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(degree == "darkness", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "darkness", gsub("fur color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "darkness", gsub("fur", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "temperature_h", gsub("day", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "loudness_n", gsub("day", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "seasons", gsub("day this month", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "price", gsub("day", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "price", gsub("flats", "apartments", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "speed", gsub("kid", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "height", gsub("kid", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "loudness", gsub("kid", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "strength", gsub("kid", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "weight", gsub("kid", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "people", gsub("kid", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "width", gsub("lane", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "darkness", gsub("light", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    # response_lemma_hand = ifelse(degree == "height",  gsub("mall", np_match, response_lemma_hand),
    #                          response_lemma_hand),
    response_lemma_hand = ifelse(np_match == "strip malls", gsub("mall", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "speed_f", gsub("planes", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "height", gsub("player", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "temperature_h", gsub("rinks", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "temperature_h", gsub("saturday", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "animals", gsub("shade", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "loudness_n", gsub("time", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "temperature_h", gsub("time", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "speed", gsub("time", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "price", gsub("time", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "birds", gsub("times of day", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "darkness", gsub("time", "times of day", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "price", gsub("store", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "price", gsub("shop", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "size", gsub("store", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "loudness_n", gsub("store", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "length_duration", gsub("store", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(degree == "temperature_h", gsub("sip", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "animals", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "cakes", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "flowers", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "materials", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "birds", gsub("color", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "birds", gsub("locations", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma = ifelse(degree == "darkness", gsub("times", "times of day", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = gsub("top shelf options", "liquor", response_lemma_hand),
    response_lemma_hand = ifelse(degree == "price", gsub("rent", "rentals", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "paints", gsub("color", "paint", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "seasons", gsub("day", "seasons", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "statues", gsub("material", "statues", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "insects", gsub("bug", "insect", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "cookware", gsub("cook", "cookware", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "venues", gsub("auditoriums", "concert", response_lemma_hand),
      response_lemma
    ),
    response_lemma_hand = ifelse(degree == "speed", gsub("appliances", "cookware", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = gsub("market", np_match, response_lemma_hand),
    response_lemma_hand = gsub("playing", np_match, response_lemma_hand),
    response_lemma_hand = gsub("saturday nights", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "places", gsub("venues", "places", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "concerts", gsub("singing", "concerts", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(degree == "strength", gsub("body", "athlete", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "materials", gsub("cloth", "fabric", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "shoes", gsub("shes", "shoes", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "concerts", gsub("show", "concert", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "audios", gsub("show", "audio", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "statues", gsub("metal", "statue", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "cookware", gsub("method", "cookware", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "venues", gsub("night", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "doorways", gsub("opening", "doorway", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "dens", gsub("opening", "den", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "times of day", gsub("area", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "times of day", gsub("places", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "times of day", gsub("area", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "times of day", gsub("street", np_match, response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "rentals", gsub("places", "rentals", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "food", gsub("dishes", "food", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "restaurants", gsub("places", "restaurants", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "restaurants", gsub("places dinner", "restaurants", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "alcoholic drinks", gsub("places", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "doorways", gsub("path", "doorway", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "dens", gsub("passage", "den", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "roads", gsub("path", "road", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "waterways", gsub("path", "waterways", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "audios", gsub("performance", "audio", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "audios", gsub("music", "audio", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "materials", gsub("hardware", "materials", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "audios", gsub("performance", "venues", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "locations", gsub("places in the house", "locations", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "locations", gsub("places in the kitchen", "locations", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "locations", gsub("refrigerator", "freezer", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "doorways", gsub("places house", "doorways", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "floors", gsub("surfaces", "floors", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "races", gsub("tracks", "races", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(superordinate == "restaurants", gsub("menu", "restaurants", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "walls", gsub("building materials", "walls", response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "birds", gsub("park", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(superordinate == "birds", gsub("forest", np_match, response_lemma_hand),
      response_lemma_hand
    ),
    response_lemma_hand = ifelse(cleanedPhrase == "_cries_", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(cleanedPhrase == "_crying_", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(cleanedPhrase == "_episodes_", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(cleanedPhrase == "_car_", "cars", response_lemma_hand),
    response_lemma_hand = ifelse(cleanedPhrase == "_map_", "maps", response_lemma_hand),
    response_lemma_hand = ifelse(cleanedPhrase == "_pots_", "cookware", response_lemma_hand),
    response_lemma_hand = ifelse(cleanedPhrase == "_settings_", superordinate, response_lemma_hand),
    response_lemma_hand = ifelse(cleanedPhrase == "_pieces_", np_match, response_lemma_hand),
    response_lemma_hand = ifelse(np == "sauna", gsub("spa", "sauna", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = ifelse(np == "bedboard", gsub("board", "bedboard", response_lemma_hand), response_lemma_hand),
    response_lemma_hand = gsub("shopping", np_match, response_lemma_hand),
    response_lemma_hand = gsub("works of art", superordinate, response_lemma_hand)

    # classification of those responses which were not caught above (looking at d.tidy.resp.analysis.update below): mostly adjusting synonymous responses to get accurate mode estinates
  ) %>%
  mutate(
    cleanedPhrase = paste("_", as.character(response_lemma_hand), "_", sep = ""),
    specific = containsString_responses(as.character(cleanedPhrase), as.character(np_match), response_lemma_hand, np_match_us),
    matchingSuper = containsString_responses(as.character(cleanedPhrase), as.character(superordinate), response_lemma_hand, super_us)
  ) -> d.tidy.phrase.handClassified2
```

The responses which hereafter have no explicit marking as being subordinate or superordinate (i.e. matching the anticipated superordinate ) are all superordinate (i.e. more general than the NP) but deviate from our anticipated superordinates.

### Hand-categorized Responses Post-processing 

To further clean the data set, we exclude the responses which mention the degree which is described by the adjectives (e.g. 'price' for 'expensive' or 'cheap' ) since it does not provide a comparison class: e.g. we exclude responses like "It's warm relative to other temperatures".

``` {r}

d.tidy.phrase.handClassified2 %>% filter((specific == 0) & (matchingSuper == 0)) -> d.nonMatching.resps

# create the full dataset of hand-classified responses
d.tidy.phrase.handClassified2 <- d.tidy.phrase.handClassified2 %>% rbind(., d.tidy.phrase.handClassified.matched)

# here, the responses including the scale are caught  (229 responses)
d.scaleResps <- d.tidy.phrase.handClassified2 %>%
  rowwise() %>%
  mutate(
    degree_match = degree,
    degree_match = ifelse(degree == "temperature_h", "temperature", degree_match),
    degree_match = ifelse(degree == "speed_f", "speed", degree_match),
    degree_match = ifelse(degree == "loudness", "sound|noise", degree_match),
    degree_match = ifelse(degree == "loudness_n", "sound|noise", degree_match),
    degree_match = ifelse(degree == "length_duration", "length|duration", degree_match),
    degree_match = ifelse(degree == "strength", "weight", degree_match),
  ) %>%
  filter(grepl(degree_match, response_lemma_hand, ignore.case = T) & !(grepl("bird|animal|strawberries|road|weightlifter", response_lemma_hand)))
```

### Full Dataframe

We create the full processed dataframe by joining the automatically classified data and the hand-classified data. 
We further correct the classification of some items where the superordinate (e.g. boat) occurs in the composite subordinate (e.g. rowing boat) and hence was automatically classified as both specific and superordinate (because we match responses to NPs and vice versa). If the response is superordinate, we correct the classification. 
``` {r}
# exclude the "degree" responses
d.AutoClassified <- d.matchedResponses %>%
  select(
    workerid, stim_id, degree, context_sentence, superordinate,
    np, np_expectations, adj, adj_polarity, np_match, response,
    response_lemma, specific, matchingSuper
  )
d.HandClassified.subs.wCC <- anti_join(
  d.tidy.phrase.handClassified2, d.scaleResps
) %>% select(workerid, stim_id, degree, context_sentence, superordinate,
  np, np_expectations, adj, adj_polarity, np_match, response,
  response_lemma = response_lemma_hand, specific, matchingSuper
)

# put the whole classified data together to get modal responses
d.tidy.resps.classified.full <- rbind(d.AutoClassified, d.HandClassified.subs.wCC)


# some compounds should only be classified as superordinates
d.tidy.resps.classified.full <- d.tidy.resps.classified.full %>% mutate(
  specific = ifelse(response == "berries", 0, specific),
  specific = ifelse(response == "boat", 0, specific),
  specific = ifelse(response == "bird", 0, specific),
  specific = ifelse(response == "building", 0, specific),
  specific = ifelse(response == "cake", 0, specific),
  specific = ifelse(response == "concert", 0, specific),
  specific = ifelse(response == "flower", 0, specific),
  specific = ifelse(response == "guitar", 0, specific)
)
```


``` {r}
# check
d.tidy.resps.classified.full %>%
  filter((specific == 1) & (matchingSuper == 1)) %>%
  View()
# all the responses that are classified as both are composite subordinates

# check the full data set items which have mean 1 or 0

d.tidy.resps.classified.full %>%
  group_by(stim_id, np_expectations, adj_polarity) %>%
  mutate(meanSub = mean(specific), ) %>%
  filter((meanSub == 0) | (meanSub == 1)) %>%
  select(stim_id, degree, np_match, adj_polarity, np_expectations, originalResponse, cat_cleaned, meanSub) %>%
  distinct() %>%
  View()
```

### Frequencies

After we manually inspected the data with respect to responses systematically deviating from the anticipated ones we extracted two items (5 and 77) for which the superordinates deviated. We adjust the superordinates to the empirical modal responses and use this adjusted set of superordinates for the frequency extraction and the adjective endorsement task. 
If the response was classified as subordinate (i.e. _specific_), it is turned to be the corresponding NP, otherwise it is turned to the corresponding superordinate from this adjusted superordinates set. 
Plural NPs are created for the frequency extraction, some superordinates are adjusted in order to avoid polysemy and get more accurate frequency estimates. The corresponding subordinate and superordinate frequencies are added to each data point. 
The result of these processing steps is a dataframe containing the full processed data, where the specific responses are coerced to the NPs and the superordinate responses are coerced to the updated anticipated superordinates set.  
``` {r}
# the data is adjusted to the human modal responses for stim_ids 5 and 77

# plural noun phrases are adjusted to the frequency queries
d.tidy.resps.classified.full.adjust.Super <- d.tidy.resps.classified.full %>%
  mutate(
    # substitutions made based on human modal responses
    superordinate = ifelse(stim_id == 90, "doors", superordinate),
    superordinate = ifelse(stim_id == 5, "writing tools", superordinate),
    superordinate = ifelse(stim_id == 77, "food", superordinate)
  ) %>%
  mutate(mode_np = ifelse(specific == 1, np, superordinate))

d.tidy.resps.w.pl.np <- d.tidy.resps.classified.full.adjust.Super %>%
  rowwise() %>%
  mutate(np_pl = insert_plural_np(tolower(np), superordinate))

# adjust some superordinates
d.tidy.resps.w.pl.np <- d.tidy.resps.w.pl.np %>%
  mutate(
    superordinate.freq = superordinate,
    superordinate.freq = ifelse(superordinate == "venue", "venues", superordinate.freq),
    superordinate.freq = ifelse(superordinate == "dens", "animal dens", superordinate.freq) # avoid polysemy
  )
# this data can be fed into python frequency extractor
# write_csv(d.tidy.resps.w.pl.np, '../data/class-elicitation-prereg-final/class-elicitation-final-full_analysis_w_pl_np.csv'


df.frequencies <- read_csv("../data/class-elicitation-prereg-final/class-elicitation-final-plural_frequencies.csv")

d.tidy.phrase.w.original.mode.pl <- d.tidy.resps.w.pl.np %>%
  left_join(., df.frequencies, by = c("np_pl" = "NPs")) %>% # add subordinate frequencies
  left_join(., df.frequencies, by = c("superordinate.freq" = "NPs")) %>%
  mutate(
    degree = ifelse(degree == "length_duration", "length", degree)
  ) # add superordinate frequencies

df.mode.final <- d.tidy.phrase.w.original.mode.pl %>%
  select(workerid, stim_id, degree, superordinate.freq, adj, adj_polarity, np, np_pl, np_expectations, mode_np, specific, Frequencies.x, Frequencies.y) %>%
  mutate(superordinate_pl = superordinate.freq, NP_sg = np, NP_pl = np_pl, response = mode_np, subFreq = Frequencies.x, superFreq = Frequencies.y) %>%
  select(workerid, stim_id, degree, superordinate_pl, adj, adj_polarity, NP_sg, NP_pl, np_expectations, response, specific, subFreq, superFreq)
# write_csv(df.mode.final, "../data/class-elicitation-prereg-final/full-classified-data-w-freqs.csv")
```

## Hand-classified Responses as Superordinates

Here, a dataframe including the full processed data is created, but all hand-classified responses are marked as superordinate (i.e. speicific = 0). The classification of some items where the superordinate (e.g. boat) occurs in the composite subordinate (e.g. rowing boat) and hence was automatically classified as both specific and superordinate (because we match responses to NPs and vice versa) is also corrected. 
``` {r}
d.HandClassified.marked.as.Super <- anti_join(
  d.tidy.phrase.handClassified2, d.scaleResps
) %>%
  mutate(specific = 0) %>%
  select(workerid, stim_id, degree, context_sentence, superordinate,
    np, np_expectations, adj, adj_polarity, np_match, response,
    response_lemma = response_lemma_hand, specific, matchingSuper
  )

# create a df where all hand-calssified items are treated as superordinates
d.tidy.resps.full.handClassified.as.super <- rbind(d.AutoClassified, d.HandClassified.marked.as.Super)

d.tidy.resps.full.handClassified.as.super <- d.tidy.resps.full.handClassified.as.super %>% mutate(
  specific = ifelse(response == "berries", 0, specific),
  specific = ifelse(response == "boat", 0, specific),
  specific = ifelse(response == "bird", 0, specific),
  specific = ifelse(response == "building", 0, specific),
  specific = ifelse(response == "cake", 0, specific),
  specific = ifelse(response == "concert", 0, specific),
  specific = ifelse(response == "flower", 0, specific),
  specific = ifelse(response == "guitar", 0, specific)
)
```

### Frequencies 
Some of the superordinates (for item 5 and 77) are corrected according to the empirical modal responses that were manually extracted and used in the adjective endorsement task.
The responses that still are marked as specific were all matched automatically and are coerced to the NPs, all the superordinate responses are coerced to the updated superordinates. Plural NPs are created and some superordinates are adjusted to avoid polysemy in order to extract frequencies. The corresponding subordinate and superordinate frequencies are appendes to each data point. 
The result of these processing steps is a dataframe containing the full processed data, where the responses automatically classified as specific are marked so, and all the other responses are marked as superordinate. Each response is coerced to either the NP or the superordinate, respectively.  
``` {r}
d.tidy.resps.full.handClassified.as.super.adjust <- d.tidy.resps.full.handClassified.as.super %>%
  mutate(
    # substitutions made based on human modal responses
    superordinate = ifelse(stim_id == 90, "doors", superordinate),
    superordinate = ifelse(stim_id == 5, "writing tools", superordinate),
    superordinate = ifelse(stim_id == 77, "food", superordinate)
  ) %>%
  # if the response is specific (subordinate), the modal NP is inserted, otherwise the modal superordinate is inserted
  mutate(mode_np = ifelse(specific == 1, np, superordinate))
# data frame with hand classified responses being a priori superordinates
d.tidy.resps.full.handClassified.as.super.adjust.w.freq <- d.tidy.resps.full.handClassified.as.super.adjust %>%
  rowwise() %>%
  mutate(np_pl = insert_plural_np(tolower(np), superordinate))

d.tidy.resps.full.handClassified.as.super.adjust.w.freq <-
  d.tidy.resps.full.handClassified.as.super.adjust.w.freq %>%
  mutate(
    superordinate.freq = superordinate,
    superordinate.freq = ifelse(superordinate == "venue", "venues", superordinate.freq),
    superordinate.freq = ifelse(superordinate == "dens", "animal dens", superordinate.freq) # avois polysemy
  ) %>%
  left_join(., df.frequencies, by = c("np_pl" = "NPs")) %>% # add subordinate frequencies
  left_join(., df.frequencies, by = c("superordinate.freq" = "NPs")) %>%
  mutate(
    degree = ifelse(degree == "length_duration", "length", degree)
  ) %>%
  select(workerid, stim_id, degree,
    superordinate_pl = superordinate.freq,
    adj, adj_polarity, NP_sg = np, NP_pl = np_pl, np_expectations,
    response = mode_np, specific, subFreq = Frequencies.x, superFreq = Frequencies.y
  )
# write_csv(d.tidy.resps.full.handClassified.as.super.adjust.w.freq, '../data/class-elicitation-prereg-final/full-classified-data-w-handResps-as-super.csv')
```

## Modal Superordinate Responses
The responses that were not processed automatically are inspected in detail to find responses systematically deviating from the anticipated ones. 

### Superordinates for the Adjective Endorsement
Here, superordinate responses were extracted which deviated from the anticipated superordinates in all conditions (i.e. NPs and adejctives: 3x2). The superordinates for the item 5 and 77 were adjusted to the modal response extracted here in all data sets and were used in the adjective endorsement experiment. 

The data points form the full data set are grouped by stim id, NP expectation, adjective polarity and specificity and the number of occurances of each response is calculated. Then, the modal response is extracted. The responses are then coerced to the respective modal response (i.e. the modal response of the respective NP and adjective condition). Then those superordinates where the modal response deviates for all 6 items of a set (set is 6 variations of an item: 3 np_expectations x 2 adj_polarities) and the deviating modal response is the same for all the 6 are extracted .
``` {r}
# extract the mode response
d.tidy.resp.counts <- d.tidy.resps.classified.full %>%
  group_by(stim_id, superordinate, np_match, np_expectations, adj_polarity, specific, response_lemma) %>%
  count() %>%
  mutate(n_unique_resps = n) %>%
  ungroup()

# insert the NP  where participants gave subordinate response, modal superordinate where they gave superordinate response in column 'mode'
d.tidy.resp.counts <- d.tidy.resp.counts %>%
  group_by(stim_id, superordinate, np_match, adj_polarity, specific) %>%
  mutate(mode = response_lemma[which.max(n)])


# analysis of modal responses
d.tidy.resp.counts.analysis <- d.tidy.resp.counts %>%
  rowwise() %>%
  mutate(
    isModeNP = containsString_responses(
      as.character(paste("_", np_match, "_", sep = "")), as.character(mode),
      np_match, as.character(paste("_", mode, "_", sep = ""))
    ),
    isModeSuper = containsString_responses(
      as.character(paste("_", superordinate, "_", sep = "")), as.character(mode),
      superordinate, as.character(paste("_", mode, "_", sep = ""))
    ),
    isModeNeither = sum(isModeNP, isModeSuper),
    mode = gsub("_", "", mode)
  ) # isModeNeither = 0 means that the mode response is different from anticipated NPs

d.tidy.resp.counts.analysis %>%
  filter(isModeNeither == 0) %>%
  distinct(stim_id, degree, superordinate, np_match, specific, adj_polarity, mode) %>%
  View()

d.tidy.resp.counts.analysis %>%
  filter(isModeNeither == 0) %>%
  distinct(stim_id, degree, superordinate, np_match, specific, adj_polarity, mode) %>%
  count(stim_id, mode) %>%
  filter(n >= 6) -> stim.ids.adjust

d.tidy.resp.counts.analysis %>%
  filter(isModeNeither == 0) %>%
  distinct(stim_id, degree, superordinate, np_match, specific, adj_polarity, mode) %>%
  right_join(., stim.ids.adjust, by = c("stim_id")) %>%
  View()
```

### Common Superordinate Responses

We further conduct a more detailed analysis of the modal responses.
For the responses that are not classified automatically (i.e. are not the anticipated suboridnate or superoridnate NPs, about n = 4.000), we investigate if there are _several distinct salient superordinate responses within each item_ (classified as superordinate: all the data points that remain not matched to a priori subordinates or superordinates after the analyses are tagged as superordinate). For example, we would like to see if for the item set 'food' (anticipated superordinate) - 'soup' - 'salad' - 'ice cream' _more than three participants_ provided any superordinate responses other than 'food'. We collapse across single NPs and adjective conditions within an item, i.e. we count the response as salient if at least three participants provided the response given any NP of the item (e.g. any of 'soup', 'salad', 'ice cream') and any of the adjective (positive or negative, 'hot' or 'cold'). If the response provided by the participant was provided by at least two other participants, the response is kept, otherwise it is substituted by the a priori superordinate. The corresponding frequencies are extracted for plurals of these salient responses.     

```{r}
d.tidy.super.counts <- d.tidy.resps.classified.full %>%
  filter((specific == 0) & (matchingSuper == 0)) %>%
  group_by(stim_id, superordinate, response_lemma) %>%
  count() %>%
  mutate(n_unique_resps = n) %>%
  ungroup()

d.tidy.super.counts %>% filter(n_unique_resps >= 3) -> d.tidy.super.counts.common

d.tidy.super.counts %>%
  ungroup() %>%
  mutate(produced_super = ifelse(n_unique_resps >= 3, response_lemma, superordinate)) -> d.tidy.super.adjust
d.tidy.resps.classified.full %>%
  filter((specific == 0) & (matchingSuper == 0)) %>%
  left_join(., d.tidy.super.adjust, by = c("stim_id", "superordinate", "response_lemma")) -> d.nonMatch.adjustSuper

# get number of data points which passed the grab-3 criterion
d.nonMatch.adjustSuper %>% filter(produced_super != superordinate) # n = 2885

# get the distinct superordinates for the frequency extraction
d.nonMatch.adjustSuper %>% distinct(produced_super) -> distinctSuper
distinctSuper %>%
  rowwise() %>%
  filter(str_detect(produced_super, ".s$")) %>%
  as.list() %>%
  .$produced_super -> pluralSuper
# anti_join(distinctSuper, pluralSuper) %>% View()
super_plural <- function(n, pluralSuper) {
  if (n %in% c("music", "people", "food", "furniture", "decor", "jewelry", "wood", "weather", "fish", "transportation", "times of day", "cookware", "traffic")) {
    n_pl <- n
  } else if (n %in% pluralSuper) {
    n_pl <- n
  } else if (n == "box") {
    n_pl <- "boxes"
  } else if (n == "city") {
    n_pl <- "cities"
  } else {
    n_pl <- paste(n, "s", sep = "")
  }
  return(n_pl)
}

distinctSuper %>%
  rowwise() %>%
  mutate(produced_super_pl = super_plural(produced_super, pluralSuper)) -> allSuper

# write_csv(allSuper, "../data/class-elicitation-prereg-final/hand-classified-produced-distinct-super-pl.csv")

d.nonMatch.adjustSuper <- d.nonMatch.adjustSuper %>%
  rowwise() %>%
  mutate(produced_super_pl = super_plural(produced_super, pluralSuper))

d.nonMatch.adjustSuper.filter <- d.nonMatch.adjustSuper %>%
  rowwise() %>%
  mutate(
    degree = ifelse(degree == "length_duration", "length", degree),
    superordinate_pl = produced_super_pl,
    superordinate_pl = ifelse(superordinate_pl == "dens", "animal dens", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " kitchens", "kitchens", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " furnitures", "furniture", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " fabrics", "fabrics", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " woods", "wood", superordinate_pl),
    NP_pl = insert_plural_np(tolower(np), superordinate)
  ) %>%
  select(workerid, stim_id, degree, superordinate_pl, adj, adj_polarity,
    NP_sg = np, NP_pl, np_expectations, response = produced_super_pl, specific
  )

df.produced.super.freqs <- read_csv("../data/class-elicitation-prereg-final/hand-classified-produced-super-pl-frequencies.csv")

d.nonMatch.adjustSuper.filter.w.freqs <- d.nonMatch.adjustSuper.filter %>%
  left_join(., df.frequencies, by = c("NP_pl" = "NPs")) %>%
  left_join(., df.produced.super.freqs, by = c("superordinate_pl" = "NPs"))

d.nonMatch.adjustSuper.filter.w.freqs <- d.nonMatch.adjustSuper.filter.w.freqs %>%
  select(workerid, stim_id, degree, superordinate_pl, adj, adj_polarity, NP_sg,
    NP_pl, np_expectations, response, specific,
    subFreq = Frequencies.x, superFreq = Frequencies.y
  )

# write_csv(d.nonMatch.adjustSuper.filter.w.freqs, "../data/class-elicitation-prereg-final/hand-classified-supers-w-produced-super-w-freqs.csv")
```

## Full Data with Common Superordinates

Here, a dataframe containing the full processed data where the superordinates are the common superordinates extracted above by the 3-participants rule is created. Hence, the subordinate responses are coerced to the NPs and the superordinate responses are either unchanged if at least three such responses were produced for the respective item or coerced to the anticipated superordinate. The respective subordinate and superordiunate frequencies are added to each data point.
``` {r}
# create full df with produced grab-3 superordinates
d.tidy.phrase.w.original.mode.pl %>%
  filter((specific == 1) | (matchingSuper == 1)) %>%
  select(workerid, stim_id, degree,
    superordinate_pl = superordinate.freq,
    adj, adj_polarity, NP_sg = np, NP_pl = np_pl, np_expectations,
    response = mode_np, specific, subFreq = Frequencies.x, superFreq = Frequencies.y
  ) %>%
  rbind(., d.nonMatch.adjustSuper.filter.w.freqs) -> d.full.w.produced.super

# write_csv(d.full.w.produced.super, "../data/class-elicitation-prereg-final/full-classified-data-w-produced-super.csv")
```

### Responses Failing Reference  

Among the common superordinate responses extracted above we found some which fail to establish correct reference for the given context. For example, for item 90 ('Lisa is considering moving her furniture through the {front gate, patio door, back door}. She says: It's {wide, narrow}'.) the response 'furniture' does not refer to the NPs. We manually extracted these cases of failed reference.
``` {r}
# exclusiopn of responses where reference fails based on non-matching superordinate analysis above
d.tidy.resps.classified.full %>%
  filter((specific == 0) & (matchingSuper == 0)) %>%
  filter(
    ((stim_id == 90) & grepl("furniture", response_lemma)) |
      ((stim_id == 88) & grepl("bank", response_lemma)) |
      ((stim_id == 54) & grepl("vegetable", response_lemma)) |
      ((stim_id == 55) & grepl("bird", response_lemma)) |
      ((stim_id == 67) & grepl("box", response_lemma)) |
      ((stim_id == 26) & grepl("map", response_lemma)) |
      ((stim_id == 9) & grepl("fruit", response_lemma))
  ) -> d.tidy.resp.failedRef
# write_csv(d.tidy.resp.failedRef, '../data/class-elicitation-prereg-final/data-classified-failing-reference.csv')
```

### Common Superordinate Responses without Failing Reference

Here, common superordinate responses are extracted from data where the responses failing reference are removed. The procedure mirrors the one above: We collapse across single NPs and adjective conditions within an item, i.e. we count the response as salient if at least three participants provided the response given any NP of the item (e.g. any of 'soup', 'salad', 'ice cream') and any of the adjective (positive or negative, 'hot' or 'cold'). If the response provided by the participant was provided by at least two other participants, the response is kept, otherwise it is substituted by the a priori superordinate. The corresponding frequencies are extracted for plurals of these salient responses. 
```{r}
# without failed reference
d.tidy.super.counts.nfR <- d.tidy.resps.classified.full %>%
  anti_join(., d.tidy.resp.failedRef) %>%
  filter((specific == 0) & (matchingSuper == 0)) %>%
  group_by(stim_id, superordinate, response_lemma) %>%
  count() %>%
  mutate(n_unique_resps = n) %>%
  ungroup()

d.tidy.super.counts.nfR %>% filter(n_unique_resps >= 3) -> d.tidy.super.counts.common.nfR

d.tidy.super.counts.nfR %>%
  ungroup() %>%
  mutate(produced_super = ifelse(n_unique_resps >= 3, response_lemma, superordinate)) -> d.tidy.super.adjust.nfR
d.tidy.resps.classified.full %>%
  anti_join(., d.tidy.resp.failedRef) %>%
  filter((specific == 0) & (matchingSuper == 0)) %>%
  left_join(., d.tidy.super.adjust, by = c("stim_id", "superordinate", "response_lemma")) -> d.nonMatch.adjustSuper.nfR

# get number of data points which passed the grab-3 criterion
d.nonMatch.adjustSuper.nfR %>% filter(produced_super != superordinate) # n = 2539

# get the distinct superordinates for the frequency extraction
d.nonMatch.adjustSuper.nfR %>% distinct(produced_super) -> distinctSuper.nfR
distinctSuper.nfR %>%
  rowwise() %>%
  filter(str_detect(produced_super, ".s$")) %>%
  as.list() %>%
  .$produced_super -> pluralSuper.nfR
d.nonMatch.adjustSuper.nfR <- d.nonMatch.adjustSuper.nfR %>%
  rowwise() %>%
  mutate(produced_super_pl = super_plural(produced_super, pluralSuper))

d.nonMatch.adjustSuper.filter.nfR <- d.nonMatch.adjustSuper %>%
  rowwise() %>%
  mutate(
    degree = ifelse(degree == "length_duration", "length", degree),
    superordinate_pl = produced_super_pl,
    superordinate_pl = ifelse(superordinate_pl == "dens", "animal dens", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " kitchens", "kitchens", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " furnitures", "furniture", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " fabrics", "fabrics", superordinate_pl),
    superordinate_pl = ifelse(superordinate_pl == " woods", "wood", superordinate_pl),
    NP_pl = insert_plural_np(tolower(np), superordinate)
  ) %>%
  select(workerid, stim_id, degree, superordinate_pl, adj, adj_polarity,
    NP_sg = np, NP_pl, np_expectations, response = produced_super_pl, specific
  )

df.produced.super.freqs <- read_csv("../data/class-elicitation-prereg-final/hand-classified-produced-super-pl-frequencies.csv")

d.nonMatch.adjustSuper.filter.w.freqs.nfR <- d.nonMatch.adjustSuper.filter.nfR %>%
  left_join(., df.frequencies, by = c("NP_pl" = "NPs")) %>%
  left_join(., df.produced.super.freqs, by = c("superordinate_pl" = "NPs"))

d.nonMatch.adjustSuper.filter.w.freqs.nfR <- d.nonMatch.adjustSuper.filter.w.freqs.nfR %>%
  select(workerid, stim_id, degree, superordinate_pl, adj, adj_polarity, NP_sg,
    NP_pl, np_expectations, response, specific,
    subFreq = Frequencies.x, superFreq = Frequencies.y
  )

# write_csv(d.nonMatch.adjustSuper.filter.w.freqs, "../data/class-elicitation-prereg-final/nonmatched-produced-super-w-freqs.csv")
```

## Full Data without Failed Reference

Here, a dataframe containing the full processed data from which the responses failing reference were excluded is created. The superordinates of the two items 5 and 77 are adjusted to the empirical modal ones; the responses marked as specific are coerced to the NPs, the responses marked as superordinate are coerced to the updated superordinates set. Plural NPs and adjusted superordinates (to avoid polysemy) are ceated for the frequency extraction. Respective subordinate and superordinate frequencies are added to each data point. 
```{r frequencies}
d.tidy.resps.classified.full.adjust.Super.nfR <- d.tidy.resps.classified.full %>%
  anti_join(., d.tidy.resp.failedRef) %>%
  mutate(
    # substitutions made based on human modal responses
    superordinate = ifelse(stim_id == 90, "doors", superordinate),
    superordinate = ifelse(stim_id == 5, "writing tools", superordinate),
    superordinate = ifelse(stim_id == 77, "food", superordinate)
  ) %>%
  # if the response is specific (subordinate), the modal NP is inserted, otherwise the modal superordinate is inserted
  mutate(mode_np = ifelse(specific == 1, np, superordinate))

d.tidy.resps.w.pl.np.nfR <- d.tidy.resps.classified.full.adjust.Super.nfR %>%
  rowwise() %>%
  mutate(np_pl = insert_plural_np(tolower(np), superordinate))

# adjust some superordinates
d.tidy.resps.w.pl.np.nfR <- d.tidy.resps.w.pl.np.nfR %>%
  mutate(
    superordinate.freq = superordinate,
    superordinate.freq = ifelse(superordinate == "venue", "venues", superordinate.freq),
    superordinate.freq = ifelse(superordinate == "dens", "animal dens", superordinate.freq) # avois polysemy
  )

# nfR
d.tidy.phrase.w.original.mode.pl.nfR <- d.tidy.resps.w.pl.np.nfR %>%
  left_join(., df.frequencies, by = c("np_pl" = "NPs")) %>% # add subordinate frequencies
  left_join(., df.frequencies, by = c("superordinate.freq" = "NPs")) %>%
  mutate(
    degree = ifelse(degree == "length_duration", "length", degree)
  ) # add superordinate frequencies

df.mode.final.nfR <- d.tidy.phrase.w.original.mode.pl.nfR %>%
  select(workerid, stim_id, degree, superordinate.freq, adj, adj_polarity, np, np_pl, np_expectations, mode_np, specific, Frequencies.x, Frequencies.y) %>%
  mutate(superordinate_pl = superordinate.freq, NP_sg = np, NP_pl = np_pl, response = mode_np, subFreq = Frequencies.x, superFreq = Frequencies.y) %>%
  select(workerid, stim_id, degree, superordinate_pl, adj, adj_polarity, NP_sg, NP_pl, np_expectations, response, specific, subFreq, superFreq)

# write_csv(df.mode.final.nfR, "../data/class-elicitation-prereg-final/full-classified-data-w-freqs-no-failedeRef.csv")
```

## Hand-classified Responses as Superopridnates without failing Reference

Here, a dataframe containing the full processed data from which the responses failing reference were excluded is created, but all hand-classified responses are marked as superordinate (i.e. speicific = 0). The superordinates of the two items 5 and 77 are adjusted to the empirical modal ones; the responses marked as specific are coerced to the NPs, the responses marked as superordinate are coerced to the updated superordinates set. Plural NPs and adjusted superordinates (to avoid polysemy) are ceated for the frequency extraction. Respective subordinate and superordinate frequencies are added to each data point. 

``` {r}

# exlcude failing Reference
d.tidy.resps.full.handClassified.as.super.adjust.nfR <- d.tidy.resps.full.handClassified.as.super %>%
  anti_join(., d.tidy.resp.failedRef) %>%
  mutate(
    # substitutions made based on human modal responses
    superordinate = ifelse(stim_id == 90, "doors", superordinate),
    superordinate = ifelse(stim_id == 5, "writing tools", superordinate),
    superordinate = ifelse(stim_id == 77, "food", superordinate)
  ) %>%
  # if the response is specific (subordinate), the modal NP is inserted, otherwise the modal superordinate is inserted
  mutate(mode_np = ifelse(specific == 1, np, superordinate))

# nfR
# data frame with hand classified responses being a priori superordinates
d.tidy.resps.full.handClassified.as.super.adjust.w.freq.nfR <- d.tidy.resps.full.handClassified.as.super.adjust.nfR %>%
  rowwise() %>%
  mutate(np_pl = insert_plural_np(tolower(np), superordinate))
d.tidy.resps.full.handClassified.as.super.adjust.w.freq.nfR <-
  d.tidy.resps.full.handClassified.as.super.adjust.w.freq.nfR %>%
  mutate(
    superordinate.freq = superordinate,
    superordinate.freq = ifelse(superordinate == "venue", "venues", superordinate.freq),
    superordinate.freq = ifelse(superordinate == "dens", "animal dens", superordinate.freq) # avois polysemy
  ) %>%
  left_join(., df.frequencies, by = c("np_pl" = "NPs")) %>% # add subordinate frequencies
  left_join(., df.frequencies, by = c("superordinate.freq" = "NPs")) %>%
  mutate(
    degree = ifelse(degree == "length_duration", "length", degree)
  ) %>%
  select(workerid, stim_id, degree,
    superordinate_pl = superordinate.freq,
    adj, adj_polarity, NP_sg = np, NP_pl = np_pl, np_expectations,
    response = mode_np, specific, subFreq = Frequencies.x, superFreq = Frequencies.y
  )
# write_csv(d.tidy.resps.full.handClassified.as.super.adjust.w.freq.nfR, '../data/class-elicitation-prereg-final/full-classified-data-w-handResps-as-super-no-failedRef.csv')
``` 

## Full Data with Common Superordinates without failing Reference

Here, a dataframe containing the full processed data from which the responses failing reference were excluded is created, where the superordinates are the common superordinates extracted above by the 3-participants rule. Hence, the subordinate responses are coerced to the NPs and the superordinate responses are either unchanged if at least three such responses were produced for the respective item or coerced to the anticipated superordinate. The respective subordinate and superordiunate frequencies are added to each data point.
``` {r}
# nfR
d.tidy.phrase.w.original.mode.pl %>%
  filter((specific == 1) | (matchingSuper == 1)) %>%
  select(workerid, stim_id, degree,
    superordinate_pl = superordinate.freq,
    adj, adj_polarity, NP_sg = np, NP_pl = np_pl, np_expectations,
    response = mode_np, specific, subFreq = Frequencies.x, superFreq = Frequencies.y
  ) %>%
  rbind(., d.nonMatch.adjustSuper.filter.w.freqs.nfR) -> d.full.w.produced.super.nfR

# write_csv(d.full.w.produced.super.nfR, "../data/class-elicitation-prereg-final/full-classified-data-w-produced-super-no-failedRef.csv")
```

# Visualisations

```{r}

d.tidy.phrase.specificMarking.bs <- d.tidy.clean.responses %>%
  group_by(np_expectations, adj_polarity) %>%
  tidyboot_mean(column = specific)

d.tidy.phrase.specificMarking.bs.item <- d.tidy.clean.responses %>%
  group_by(stim_id, degree, superordinate, np_expectations, np, adj_polarity) %>%
  tidyboot_mean(column = specific)

d.tidy.phrase.specificMarking.bs %>%
  ungroup() %>%
  mutate(
    np_expectations = gsub('\"', "", np_expectations),
    adj_polarity = gsub('\"', "", adj_polarity),
    np_expectations = factor(np_expectations,
      levels = c("low", "medium", "high")
    )
  ) -> d.tidy.phrase.specificMarking.bs

d.tidy.phrase.specificMarking.bs.item %>%
  ungroup() %>%
  mutate(unique_id = paste(stim_id, np_expectations, sep = "-")) %>%
  mutate(np_expectations = factor(np_expectations,
    levels = c("low", "medium", "high")
  )) -> d.tidy.phrase.specificMarking.bs.item

# save(d.tidy.phrase.specificMarking.bs, d.tidy.phrase.specificMarking.bs.item, file = "../writing/paper/cached_results/class-elicitation-bs-byItem.RData")
load(file = "../writing/paper/cached_results/class-elicitation-bs-byItem.RData") # d.tidy.phrase.specificMarking.bs, d.tidy.phrase.specificMarking.bs.item, file =

set.seed(2020)

d.tidy.phrase.specificMarking.bs.item %>%
  left_join(
    .,
    data.frame(
      unique_id = unique(d.tidy.phrase.specificMarking.bs.item$unique_id),
      jitterVal = runif(270, min = -0.07, max = 0.07)
    )
  ) %>%
  mutate(
    jitterVal = jitterVal + ifelse(adj_polarity == "positive", 0.2, -0.2)
  ) %>%
  ggplot(
    .,
    aes(
      x = as.numeric(np_expectations) + jitterVal, y = mean,
      ymin = ci_lower, ymax = ci_upper, fill = adj_polarity
    )
  ) +
  geom_col(
    data = d.tidy.phrase.specificMarking.bs,
    aes(
      x = np_expectations, y = mean,
      ymin = ci_lower, ymax = ci_upper, fill = adj_polarity
    ),
    position = position_dodge(0.8), width = 0.8, alpha = 0.6, color = "black", size = 1
  ) +
  geom_point( # position = position_dodge(0.8),
    # position = position_jitterdodge(jitter.width = 0.2, jitter.height = 0),
    # data = d.tidy.phrase.specificMarking.bs.item,
    # aes( y = mean, fill = adj_polarity, x = np_expectations),
    shape = 21, alpha = 0.8
  ) +
  geom_path(aes(group = unique_id),
    # position = position_dodge(0.8),
    alpha = 0.15
  ) +
  geom_linerange(
    data = d.tidy.phrase.specificMarking.bs,
    aes(
      x = np_expectations, y = mean,
      ymin = ci_lower, ymax = ci_upper
    ),
    position = position_dodge(0.8), color = "black", size = 1.5
  ) +
  scale_fill_brewer(palette = "Set3") +
  theme( # axis.text.x = element_text(angle = 45, hjust = 1.0, vjust = 1),
    # axis.title.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    axis.line = element_line(colour = "black")
  ) +
  guides(fill = guide_legend(title = "Adjective polarity", reverse = T)) +
  # theme_black()+
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  ylab("Proportion paraphrases that contain Specific NP") +
  xlab("Subordinate Category General Expectations")

ggsave(
  filename = "../writing/paper/figs/bars_cc_finalExpt_prereg_bars_syncDodge.pdf",
  width = 6, height = 4
)

# save(d.tidy.phrase.specificMarking.bs.item, file = "d_comparisonClass_specific_bs_item.RData")
```


```{r}
# look at data matched automatically by-item
d.confident.phrase.specificMarking.bs.item <- d.matchedResponses %>%
  # mutate() %>%
  group_by(stim_id, degree, superordinate, np_expectations, np, adj_polarity) %>%
  mean(specific)

d.tidy.phrase.specificMarking.bs %>%
  ungroup() %>%
  mutate(
    np_expectations = gsub('\"', "", np_expectations),
    adj_polarity = gsub('\"', "", adj_polarity),
    np_expectations = factor(np_expectations,
      levels = c("low", "medium", "high")
    )
  ) %>%
  ggplot(
    .,
    aes(
      x = np_expectations, y = mean,
      ymin = ci_lower, ymax = ci_upper, fill = adj_polarity
    )
  ) +
  geom_col(position = position_dodge(0.8), width = 0.8, alpha = 0.6, color = "black", size = 1) +
  geom_point(
    position = position_jitterdodge(jitter.width = 0.2, jitter.height = 0),
    data = d.tidy.phrase.specificMarking.bs.item,
    aes(y = mean, fill = adj_polarity, x = np_expectations),
    shape = 21, alpha = 0.8
  ) +
  geom_linerange(position = position_dodge(0.8), color = "black", size = 1) +
  scale_fill_brewer(palette = "Set3") +
  theme( # axis.text.x = element_text(angle = 45, hjust = 1.0, vjust = 1),
    # axis.title.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    axis.line = element_line(colour = "black")
  ) +
  # theme_black()+
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  ylab("Proportion paraphrases that contain Specific NP") +
  xlab("Subordinate Category General Expectations")

# ggsave(filename = "../writing/paper/figs/bars_cc_finalExpt_prereg_bars.pdf",
#        width = 6, height = 4)
```

## By-item plots

```{r figIndivItems}
select.items <- d.tidy.phrase.specificMarking.bs.item %>%
  select(degree, np, stim_id, superordinate, np_expectations, adj_polarity, mean) %>%
  rowwise() %>%
  mutate(degree = first(strsplit(degree, "_")[[1]])) %>%
  spread(adj_polarity, mean) %>%
  mutate(delta = positive - negative) %>%
  ungroup() %>%
  group_by(degree, stim_id, superordinate) %>%
  summarize(mean_delta = mean(abs(delta)))

select.items %>%
  group_by(degree) %>%
  mutate(
    max_val = max(mean_delta),
    min_val = min(mean_delta)
  ) %>%
  ungroup() %>%
  filter(mean_delta == max_val | mean_delta == min_val) %>%
  pull(stim_id) -> select.item.ids

# swap tall/short people with tall/short flowers
select.item.ids <- c(select.item.ids[select.item.ids != 17], 18)

# 17 for 18

# select.items[with(select.items, order(mean_delta)), ][seq(1, 90, 3), ]

d.tidy.phrase.specificMarking.bs.item %>%
  filter(stim_id %in% select.item.ids) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(degree = first(strsplit(degree, "_")[[1]])) %>%
  ungroup() %>%
  mutate(
    np_expectations = gsub('\"', "", np_expectations),
    adj_polarity = gsub('\"', "", adj_polarity),
    np_expectations = factor(np_expectations,
      levels = c("low", "medium", "high")
    ),
    np = fct_reorder(np, as.numeric(np_expectations)),
    item_set = paste(degree, " - ", superordinate, "-", stim_id, sep = ""),
    item_name = paste(superordinate, " (", degree, ")", sep = ""),
    item_name = factor(item_name),
    item_set = factor(item_set),
    item_name = fct_reorder(item_name, as.numeric(item_set))
  ) %>%
  ggplot(
    .,
    aes(x = np, y = mean, fill = adj_polarity)
  ) +
  geom_col(position = position_dodge(0.8), width = 0.8, alpha = 0.7, color = "black") +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper),
    position = position_dodge(0.8), color = "black"
  ) +
  scale_fill_brewer(palette = "Set3") +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 0.8, vjust = 0.85),
    # axis.title.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    axis.line = element_line(colour = "black"),
    legend.position = "bottom"
  ) +
  facet_wrap(~item_name, scales = "free", nrow = 4) +
  # theme_black()+
  scale_y_continuous(limits = c(-0.02, 1.02), breaks = c(0, 0.5, 1)) +
  guides(fill = guide_legend(title = "Adjective polarity", reverse = T)) +
  ylab("Proportion paraphrases that contain Specific NP") +
  xlab("Specific Category") #-> bars_cc_finalExpt_prereg_confident_byItem

# ggsave("../analysis/figs/bars_cc_finalExpt_pilot_byItem.png",
#        width = 9, height = 9)
ggsave(
  filename = "../writing/paper/figs/bars_cc_finalExpt_prereg_byItem.pdf",
  width = 15, height = 10
)
```

# Regression modeling

### Simulate data to get contrast coding right

```{r}
simulated.data <- bind_rows(
  data.frame(
    np = "mid",
    adj = "short",
    x = rnorm(n = 20, mean = 1, sd = 0.5)
  ),
  data.frame(
    np = "mid",
    adj = "tall",
    x = rnorm(n = 20, mean = 1, sd = 0.5)
  ),
  data.frame(
    np = "low",
    adj = "short",
    x = rnorm(n = 20, mean = 0.5, sd = 0.5)
  ),
  data.frame(
    np = "low",
    adj = "tall",
    x = rnorm(n = 20, mean = 1.5, sd = 0.5)
  ),
  data.frame(
    np = "high",
    adj = "short",
    x = rnorm(n = 20, mean = 1.5, sd = 0.5)
  ),
  data.frame(
    np = "high",
    adj = "tall",
    x = rnorm(n = 20, mean = 0.5, sd = 0.5)
  )
) %>%
  mutate(
    np = factor(np, levels = c("mid", "low", "high")),
    adj = factor(adj, levels = c("short", "tall"))
  )

simulated.data.means <- simulated.data %>%
  group_by(np, adj) %>%
  summarize(m = mean(x))

simulated.data.means %>%
  ggplot(., aes(x = np, y = m, fill = adj)) +
  geom_col(position = position_dodge())


contrasts(simulated.data$adj) <- c(-0.5, 0.5)

contrasts(simulated.data$np)

lm.sim <- lm(x ~ np * adj, data = simulated.data)

lm.sim.summ <- summary(lm.sim)

sim.int <- lm.sim.summ$coefficients[["(Intercept)", "Estimate"]]
sim.beta_adj <- lm.sim.summ$coefficients[["adj1", "Estimate"]]
sim.beta_npLow <- lm.sim.summ$coefficients[["nplow", "Estimate"]]
sim.beta_npHigh <- lm.sim.summ$coefficients[["nphigh", "Estimate"]]
sim.beta_npLow_adj <- lm.sim.summ$coefficients[["nplow:adj1", "Estimate"]]
sim.beta_npHigh_adj <- lm.sim.summ$coefficients[["nphigh:adj1", "Estimate"]]

print(
  paste(
    "actual mean of MID tall",
    simulated.data.means %>% filter(np == "mid", adj == "tall") %>% pull(m),
    "model prediction",
    sim.int + 0.5 * sim.beta_adj
  )
)

print(
  paste(
    "actual mean of MID short",
    simulated.data.means %>% filter(np == "mid", adj == "short") %>% pull(m),
    "model prediction",
    sim.int - 0.5 * sim.beta_adj
  )
)

print(
  paste(
    "actual mean of HIGH tall",
    simulated.data.means %>% filter(np == "high", adj == "tall") %>% pull(m),
    "model prediction",
    sim.int + 0.5 * sim.beta_adj + sim.beta_npHigh + 0.5 * sim.beta_npHigh_adj
  )
)

print(
  paste(
    "actual mean of HIGH short",
    simulated.data.means %>% filter(np == "high", adj == "short") %>% pull(m),
    "model prediction",
    sim.int - 0.5 * sim.beta_adj + sim.beta_npHigh - 0.5 * sim.beta_npHigh_adj
  )
)

print(
  paste(
    "actual mean of LOW tall",
    simulated.data.means %>% filter(np == "low", adj == "tall") %>% pull(m),
    "model prediction",
    sim.int + 0.5 * sim.beta_adj + sim.beta_npLow + 0.5 * sim.beta_npLow_adj
  )
)

print(
  paste(
    "actual mean of LOW short",
    simulated.data.means %>% filter(np == "low", adj == "short") %>% pull(m),
    "model prediction",
    sim.int - 0.5 * sim.beta_adj + sim.beta_npLow - 0.5 * sim.beta_npLow_adj
  )
)
```


#### Full model


```{r}
d.tidy.clean.responses.fac <- d.tidy.clean.responses %>%
  mutate(
    adj_polarity = factor(adj_polarity,
      levels = c("negative", "positive")
    ),
    np_expectations = factor(np_expectations,
      levels = c("medium", "low", "high")
    )
  )

d.tidy.clean.responses.fac$stim_id <- as.factor(d.tidy.clean.responses.fac$stim_id)
d.tidy.clean.responses.fac$workerid <- as.factor(d.tidy.clean.responses.fac$workerid)

contrasts(d.tidy.clean.responses.fac$adj_polarity) <- c(-1 / 2, 1 / 2)

rs.glm.brm <- brm(
  formula = specific ~ np_expectations * adj_polarity +
    (1 + np_expectations * adj_polarity | workerid) +
    (1 + np_expectations * adj_polarity | stim_id),
  family = bernoulli(), chains = 3, cores = 3, iter = 1000,
  data = d.tidy.clean.responses.fac
)


rs.glm.brm.summary <- summary(rs.glm.brm)

rs.glm.brm.summary
```

```{r}
write_csv(data.frame(rs.glm.brm.summary[["fixed"]]) %>%
  mutate(Rowname = row.names(.)),
path = "../writing/paper/csv_data_4_tex/expt3_brm_pilot.csv"
)
```


#### Simple effects


```{r}
rs.glm <- glmer(
  formula = specific ~ np_positiveness * adj_positiveness +
    (1 | workerid) +
    (1 | superordinate),
  family = "binomial",
  data = d.tidy.phrase.w.original.fac
)

contrasts(d.tidy.phrase.w.original.fac$np_positiveness)

summary(rs.glm)
```
