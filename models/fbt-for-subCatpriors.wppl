var utterances = {
  positive: ["positiveAdjective", "silence"],
  negative: ["negativeAdjective", "silence"]
};

var utterancePrior = {
  positive: Infer({
    model: function() { return uniformDraw(utterances.positive) }
  }),
  negative: Infer({
    model: function() { return uniformDraw(utterances.negative) }
  })
};


var meaning = function(utterance, state, threshold) {
  utterance == "positiveAdjective" ? state > threshold :
  utterance == "negativeAdjective" ? state < threshold :
  true
}

var classPrior = Infer({
  model: function(){return uniformDraw(["sub", "super"])}
});

var data = repeat(100, function(){flip(0.9)})

var model = function(){

  var mu = uniform(-2, 2); // suncat mean is restricted to be +/- 2 stdev from supercat mean
  var sigma = uniform(0, 1); // subcat variance should be lower than supercat variance

  var alphas = {s1: 3, s2: 1}; // might need to put uncertainty over alphas

  var binParam = 5;

  var round = function(x){
    return Math.round(x*10)/10
  }

  var stateParams = {
    sub: {mu: mu, sigma: sigma},
    super: {mu: 0, sigma: 1}
  }

  var stateVals = map(
    round,
    _.range(stateParams.super.mu - 2.5 * stateParams.super.sigma,
            stateParams.super.mu + 2.5 * stateParams.super.sigma,
            stateParams.super.sigma/binParam)
  );

  var stateProbs = {
    sub: map(function(s){
      Math.exp(Gaussian(stateParams.sub).score(s));
    }, stateVals),
    super: map(function(s){
      Math.exp(Gaussian(stateParams.super).score(s));
    }, stateVals)
  };

  var statePrior = {
    sub: Infer({
      model: function(){ return categorical({vs: stateVals, ps: stateProbs.sub}) }
    }),
    super: Infer({
      model: function(){
        return categorical({
          vs: stateVals,
          ps: stateProbs.super
        })
      }
    })
  };

  var thresholdBins ={
    positive: map(function(x){
      return  x - (1/(binParam*2));
    }, sort(statePrior.super.support())),
    negative: map(function(x){
      return  x + (1/(binParam*2));
    }, sort(statePrior.super.support()))
  };

  var thresholdPrior = {
    positive: Infer({
      model: function() { return uniformDraw(thresholdBins.positive) }
    }),
    negative: Infer({
      model: function() { return uniformDraw(thresholdBins.negative) }
    })
  };


  var literalListener = cache(function(utterance, threshold) {
    Infer({model: function(){
      var state = sample(statePrior["super"]);
      var m = meaning(utterance, state, threshold);
      condition(m);
      return state;
    }})
  }, 10000)

  var form = "positive";

  var speaker1 = cache(function(state, threshold) {
    Infer({model: function(){
      var utterance = sample(utterancePrior[form])
      var L0 = literalListener(utterance, threshold)
      factor( alphas.s1 * L0.score(state) )
      return utterance
    }})
  }, 10000)

  var pragmaticListener = cache(function(utterance) {
    Infer({model: function(){
      var state = sample(statePrior["super"]);
      var threshold = sample(thresholdPrior[form]);
      var S1 = speaker1(state, threshold);
      observe(S1, utterance);
      return state
    }})
  }, 10000)

  var speaker2 = function(comparisonClass){
    Infer({model: function(){
      var state = sample(statePrior[comparisonClass]);
      var utterance = sample(utterancePrior[form]);
      var L1 = pragmaticListener(utterance)
      factor( alphas.s2 * L1.score(state) )
      return utterance == "positiveAdjective"
      }})
  }

  var speakerProbs = speaker2("sub");

  mapData({data}, function(d){
    observe(speakerProbs, d)
  })

  return mu
}

Infer({model, method: "MCMC", samples: 50, burn: 25, verbose: true})
